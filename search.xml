<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<blockquote>
<p>学习使用Hexo+Next搭建博客网站，这是第一篇博客！<br>文章将有以下分类：工具、技术、笔记、思考、生活、阅读、音乐。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/10121.html</url>
    <content><![CDATA[<blockquote>
<p>Hexo博客搭建及主题美化，来自<a href="https://yuumiy.github.io/posts/2789.html">岛田悠米的博客。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/62992.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>作为计算机专业科班的学生，想必学习算法的时候肯定学过<strong>排序</strong>。找工作面试的时候面试官也经常让手撕快排、堆排序等，所以总结一下关于（内部）排序算法的知识点还是很有必要滴！<br>废话不多说我们开始吧~</p>
</blockquote>
<p><img data-src="/posts/62992/hello.jpg"></p>
<span id="more"></span>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。<br>由插入排序的的思想可以引申出三个重要的排序算法：<em>直接插入排序</em>、<em>折半插入排序</em>和<em>希尔排序</em>。下面依次进行介绍~</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];  <span class="comment">// nums[0]哨兵，不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; nums[<span class="number">0</span>] &lt; nums[j]; --j)</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 复制nums[0]到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：最好情况O(n)，最坏情况O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)； <strong>稳定性</strong>：由于每次插入元素时总是从后往前先比较再移动，所以不会出现相等元素相对位置发生变化的情况，即直接插入排序是一种稳定的排序方法</p>
</blockquote>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; nums[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        nums[high+<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：折半插入排序仅减少了比较元素的次数，而元素的移动次数并未改变，因此时间复杂度仍为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-dk]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>]&lt;nums[j]; j -= dk)</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                nums[j+dk] = nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：n在某个特定范围内时，希尔排序时间复杂度为O(n<sup>1.3</sup>)，最坏情况下复杂度为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>所谓交换，就是指根据序列中两个元素的比较结果来对换这两个记录在序列中的位置。交换排序的算法很多，本文主要介绍冒泡排序和快速排序。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j<span class="number">-1</span>], nums[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;  <span class="comment">// 本趟没有发生交换，说明序列已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(n)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是对冒泡排序的一种改进，其基本思想是基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[low];  <span class="comment">// 第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) --high;</span><br><span class="line">        nums[low] = nums[high];  <span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">        nums[high] = nums[low];  <span class="comment">// 将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(nums, lowm, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(nlogn)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: 最好情况下为(logn)，最坏情况下O(n)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序基本思想是：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个。选择排序中的堆排序是考察的重点。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(nums[i], nums[min])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>建立大根堆的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, i, len);  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆向下调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿k较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">            i++;                          <span class="comment">// 取k较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=nums[i]) <span class="keyword">break</span>;       <span class="comment">// 筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];            <span class="comment">// 将nums[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                        <span class="comment">// 修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>]                     <span class="comment">// 被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(nums, len);              <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>; i--) &#123;            </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span>]);           <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, <span class="number">1</span>, i<span class="number">-1</span>);         <span class="comment">// 整理，把剩下的i-1个元素整理成堆</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点执行向上调整操作。<br>下面是堆的向上调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="keyword">int</span> nums[], inr k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参数k为向上调整的节点，也为堆的元素个数</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        nums[k] = nums[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 建堆时间复杂度O(n)，每次调整时间复杂度O(h)，故在最好、最坏和平均情况下堆排序时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>递归形式的2路归并排序算法是基于分治的其过程如下：<br>分解：将含有n个元素的待排序表分成含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。<br>合并：合并两个已经排序的子表得到排序结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;       </span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *_copy  (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt; high; k++) </span><br><span class="line">        _copy[k] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_copy[i] &lt;= _copy[j])</span><br><span class="line">            nums[k] = _copy[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = _copy[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) nums[k++] = _copy[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) nums[k++] = _copy[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 每趟归并时间复杂度为O(n)，共需logn趟归并，所以算法时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: 辅助空间占用n个单元，故空间复杂度为O(n)；<strong>稳定性</strong>：稳定</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/posts/43432.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>近期读书时摘抄的的一些使人眼前一亮的观点^.^</p>
</blockquote>
<span id="more"></span>
<h1 id="叔本华"><a href="#叔本华" class="headerlink" title="叔本华"></a>叔本华</h1><blockquote>
<p>我们读书时，是别人在代替我们思想，我们只不过重复他的思想活动的过程而已，犹如儿童启蒙习字时，用笔按照教师以铅笔所写的笔画依样画葫芦一般。我们的思想活动在读书时被免除了一大部分。因此，我们暂不自行思索而拿书来读时，会觉得很轻松，然而在读书时，我们的头脑实际上成为别人思想的运动场了。所以，读书愈多，或整天沉浸读书的人，虽然可借以休养精神，但他的思维能力必将渐次丧失，此犹如时常骑马的人步行能力必定较差，道理相同。<br><br>生命是一团欲望，欲望不能满足便痛苦，满足便无聊，人生就在痛苦和无聊之间摇摆。<br><br>一个人只有在独处时才能成为自己。谁要是不爱独处，那他就不爱自由，因为一个人只有在独处时才是真正自由的。<br><br>社交聚会要求人们做出牺牲，而一个人越具备独特的个性，那他就越难做出这样的牺牲。因此，一个人逃避、忍受抑或喜爱独处是和这一个人自身具备的价值恰成比例。因为在独处的时候，一个可怜虫就会感受到自己的全部可怜之处，而一个具有丰富思想的人只会感觉到自己丰富的思想。<br><br>学会在人群中保持一定程度上的孤独，不要有什么想法就立马告诉别人。另外，对别人所说的话千万不要太过当真。不能对别人有太多的期待，无论在道德上抑或在思想上。对于别人的看法，应锻炼出一副淡漠、无动于衷的态度，因为这是培养值得称道的宽容的一个最切实可行的手段。<br></p>
</blockquote>
<h1 id="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"><a href="#知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？" class="headerlink" title="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"></a>知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？</h1><blockquote>
<p>很多人意识不到，头顶的星空，才是生命最终极的意义所在，而我们的生活，不过是附属品而已。<br><br>低头看看你的手上的皮肤，上面的某一个原子，它来自你几天前吃下的一块牛肉，那头牛吃过一根草，这根草吸收了一片草原中的某些成分，这些成分是被一座远古火山喷出来的，那座火山喷出的都是地球内部的岩浆，这些岩浆在地球形成之前只是太阳系中的粉尘，这些粉尘来自一片星云，这片星云则来自太阳的前身星——一颗蓝巨星——垂死时产生的超新星爆发。而这颗蓝巨星诞生于更早的几亿年之前的第二代恒星死亡后的遗骸中，一直追朔到宇宙刚诞生的时候，所有这些东西都是一些夸克、胶子….你身体中所有大于铁的原子，都诞生于某颗超新星生命的最后时刻。<br><br>所以，说我们是星空的孩子，那是一点都不错的。可是你看看现在的人们，从他们的意识中，找得到一点和这有关的东西吗？找不到。人们只会关心当下的事，因为这和自己的切身利益直接相关，人们关心钱，关心亲人、爱人，关心工作，关心房价，关心友情，关心天气，将所有人类大脑与人类社会相互交杂后的必然产物掰开揉碎了分析得入木三分，然后按一种似乎是约定俗成的规则去做对自己最有利的事，将生活这一概念放大到无限大，占据了一个人内心的全部。<br><br>在这样一种大环境中，在某个晴朗无云的夜晚，在某个远离城市的静谧草原，你抬起头，一片明亮、壮丽、优雅、安详、神秘的广阔星空如一张巨幕赫然呈现在眼前，如一丝清雨将你世俗的双眼洗刷得干净透彻，什么都不剩，你与你最本质的归属之间再无任何隔阂，只有不断涌入眼中的无数星光直接打入你的内心。你怎能不感动？怎能不幸福？怎能不惊叹于世界之外这超越一切的最终极的美？这时你才意识到，你是社会的，但首先是自然的。<br><br>作者：<a href="https://www.zhihu.com/question/28006748/answer/39013684">萤火一号：</a><br><br>来源：知乎</p>
</blockquote>
<h1 id="《哲学九讲》节选"><a href="#《哲学九讲》节选" class="headerlink" title="《哲学九讲》节选"></a>《哲学九讲》节选</h1><blockquote>
<p>对于唯物主义，不管是哪种形式的唯物主义，一元论还是多元论，我们必须指出的是，物质性本体的观点到最后只能是精神上的自杀。如果构成整个宇宙的都是无意识的东西，那么我们称之为思想的东西以及思想活动，如果不能算是纯粹的物质，就只能是和热量、运动一样，作为其他物质实体的一种表现。思想与热量和运动将毫无差别，同样，我们也没有理由认为思想比温度或速度更重要。如果说思想只是某个物质实体一系列性质的表现，那它在物质上的意义就将等同于热量，而在精神上，则没有任何意义。而其所有成果，包括唯物主义本身在内，都将毫无意义，也毫无作用可言了。如果思想只是物质状态的产物，那么也就不会有什么至高无上的真理和唯物主义理论是否正确这样的问题了。所有的东西都只是像冰、水和水蒸气一样的存在，说唯物主义比唯心主义更正确，就好比说冰比水蒸气更真实一样没有意义，因为连真理这个词都是没有意义的。怀疑论者陷入了这么一个困境：如果他要否认所有观点和我们寻求真理的可能性，那他就必须同时否认支撑他去怀疑的观点，以及他意识到自己观点正确性的可能。而唯物主义者面临的困境也同样严峻。</p>
</blockquote>
<h1 id="李晓鹏《从黄河文明到一带一路·第四卷》"><a href="#李晓鹏《从黄河文明到一带一路·第四卷》" class="headerlink" title="李晓鹏《从黄河文明到一带一路·第四卷》"></a>李晓鹏《从黄河文明到一带一路·第四卷》</h1><blockquote>
<p>投票式民主并不是英国的首创，雅典和威尼斯共和国这些古老的海权国家，都是搞的投票式民主。这三个时期的代表性海权国家，都主要依靠海外殖民劫掠发迹。由于它们有大量来自于海外殖民地的财富，本国内部的生存资源争夺并不激烈。其本国底层人民，也可以从海外殖民带来的财富中获利，而无需向中国古代的农民一样，完全依靠自己的努力来养活自己和整个国家。在生存资源无忧的情况下，内部斗争——不管是统治阶级内部的利益集团之间的斗争，还是统治阶级与被统治阶级之间的斗争，都会相对缓和。也就不需要一个专制君主来决定资源分配，大多数问题用投票和开会的形式也能解决。这种民主体制，本质上是一种“分赃式民主”，是强盗们为了和平分配劫掠而来的财富所建立的程序。<br><br>英国从君主专制国家走向君主立宪制国家的背景就是这样。专制时期，还没有建立海外殖民霸权，全体国民必须自己养活自己，在国家内部分配生存资源。这个时候要组织国家资源打仗，不管是殖民战争还是争霸战争，就会面临非常严峻的国内生存资源分配问题。为了保证战争的效率和分配的公平，最佳的方案就是建立独裁君主制度。独裁君主有两个作用，一个是镇压人民反抗，但还有一个很重要的作用，就是遏制贵族的贪欲，限制他们对人民的剥夺，并强迫贵族、地主、资本家这些有钱有权的阶层多出钱来支持战争。用独裁君主制代替封建制度，是英国从弱到强的关键。等到殖民战争和争霸战争打赢了，最艰难的时刻过去了，殖民统治体系建立起来了，有众多海外殖民地可供掠夺，资源分配条件变得宽松。利益集团内部，不需要进行你死我活的斗争了；统治精英们富得流油的同时，底层人民的税负也不高、福利还不错。这种情况下，专制君主就成了一个累赘。大家就觉得还是民主好，独裁君主对贵族精英们管束的太严了、收的钱太多了，让精英们很不舒服，可以搞个科学的程序来做决策，各大利益集团选择自己的代表大家开个会各抒己见就挺好的。贵族、地主、资本家就联合起来把专制君主推翻了。决策程序慢一点没关系，吵架厉害一点没关系，不会耽误大事，利益集团之间也不会当真打起来，代议制民主就取代了独裁君主制。<br><br>近代中国的革命和改良，基本主线是中国人民与满清、汉族官僚士绅、外国列强三股反动势力反复博弈的过程。太平天国试图以底层革命的方式一次性推翻三大反动势力，壮烈失败。此后，满洲和汉族官僚士绅联合起来搞“洋务运动”，想以此富国强兵、抵御外辱，以甲午惨败结束。然后，义和团运动试图采取“扶清灭洋”的路线，联合国内两股势力共同抵御列强，遭到了汉族官僚的拒绝和满清的背叛，又被三大反动势力联合镇压。《辛丑条约》以后，满清全面投靠列强，倚靠列强榨取汉族士绅和中国人民的利益，结果就是汉族官僚士绅们开始跟革命党合作，以谋求终结满清专制，最终诱发了辛亥革命。</p>
</blockquote>
<h1 id="历史周期律"><a href="#历史周期律" class="headerlink" title="历史周期律"></a>历史周期律</h1><blockquote>
<p>历史课本告诉我们：中国封建社会存在着互相对立、彼此消长的两种土地所有制: 一是封建地主土地所有制( 包含地主阶级的国有土地制) ， 一是农民小块土地所有制。前者占支配地位， 后者为其补充。这样中国封建土地所有制实质就是封建地主土地所有制， 基本特点是土地所有权高度集中在地主阶级手中。小农经济具有其抗风险能力差的特点，普通农户家庭一旦遇到水旱蝗灾、年景歉收或是婚丧嫁娶、疾病，就不得不以土地作为抵押，从地主乡绅那里获取高利贷。<br><br>然而就像马克思和无数学者所证明的那样，历来资本的边际收益要高于劳动的边际收益，因此这就注定了在许多情况下，农民辛苦劳作所取得的收益是无法偿还高利贷的利息的。这样就在利息的“驴打滚”中恶性循环，直至将被抵押的土地偿还给地主，成为佃农，更惨一点的，就是流民。万历年间一份奏折指出：“或因水旱饥荒，及粮差繁并，或被势要相侵，及钱债驱迫，不得已将起科腴田，减其价直，典卖……”。相关的文学作品可以参考《白毛女》和茅盾先生的《春种》《秋收》。<br><br>然而，问题就来了，地主兼并农民土地，是一个线性增长财富集中愈演愈烈的趋势，但是问题就来了，因为地主士绅兼并的这些土地是不向国家交税的：<br><br>这就是造成中国封建王朝兴衰周期律的根本原因之一。土地越来越多地集中在特权阶层手中，国家能得到的赋税也就越来越少；另一方面失地流民越来越多，镇压、安抚农民起义又需要大量的财政收入，这对于封建王朝来说是一个死局。土地越集中在这些特权阶层的手中，国家受到的利益损失就越大，这就是历史上的所谓“ 锄豪强， 抑兼并”的经济思想和政策产生的经济根源。但是从公元前七年汉哀帝绥和二年颁布的封建史上的第一次限田令以来， 诸如王莽的王田制、晋初的占田制、北魏的均田制等等， 无不在既得利益的缙绅、官僚、豪强的反对下，成为一纸空文，不能实施。<br><br>来源：微信公众号”大浪淘沙”</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>哲学/历史</category>
      </categories>
      <tags>
        <tag>哲学/历史</tag>
      </tags>
  </entry>
</search>
