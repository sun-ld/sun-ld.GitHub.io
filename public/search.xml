<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第一章】</strong>道可道，非常道；名可名，非常名。无名，天地之始，有名，万物之母。故常无欲，以观其妙，常有欲，以观其徼。此两者，同出而异名，同谓之玄，玄之又玄，众妙之门。  </p>
</blockquote>
<span id="more"></span>

<p>学习使用Hexo+Next搭建博客网站，这是第一篇博客！<br>文章将有以下分类：工具、技术、笔记、思考、生活、阅读、音乐。</p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的遍历</title>
    <url>/posts/12682.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二章】</strong>天下皆知美之为美，斯恶（è）已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相较，高下相倾，音声相和（hè），前后相随。</p>
</blockquote>
<span id="more"></span>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *p = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归遍历方法-1"><a href="#递归遍历方法-1" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;left);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-1"><a href="#非递归遍历方法-1" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode *p = stk.<span class="built_in">top</span>(); </span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归遍历方法-2"><a href="#递归遍历方法-2" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-2"><a href="#非递归遍历方法-2" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk1.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk1.<span class="built_in">top</span>();</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        stk2.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk2.<span class="built_in">top</span>();</span><br><span class="line">        stk2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- # 线索化二叉树 -->

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/10121.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三章】</strong>不尚贤，使民不争；不贵难得之货，使民不为盗；不见（xiàn）可欲，使民心不乱。是以圣人之治，虚其心，实其腹；弱其志，强其骨。常使民无知无欲，使夫（fú）智者不敢为也。 </p>
</blockquote>
<!-- ![](hello.jpg) -->

<span id="more"></span>

<p>Hexo博客搭建及主题美化，来自<a href="https://yuumiy.github.io/posts/2789.html">岛田悠米的博客。</a></p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找中的lower_bound、upper_bound</title>
    <url>/posts/701.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第四章】</strong>道冲而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘。 湛兮似或存，吾不知谁之子，象帝之先。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本的二分搜索"><a href="#基本的二分搜索" class="headerlink" title="基本的二分搜索"></a>基本的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩右边界，锁定左边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 循环结束条件：left=right+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>() || nums[left]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>；</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩左侧边界，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right&lt;<span class="number">0</span> || nums[right]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/62992.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第五章】</strong>天地不仁，以万物为刍（chú）狗；圣人不仁，以百姓为刍狗。天地之间，其犹橐龠（tuó yuè）乎？虚而不屈，动而愈出。多言数（shuò）穷，不如守中。</p>
</blockquote>
<span id="more"></span>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。<br>由插入排序的的思想可以引申出三个重要的排序算法：<em>直接插入排序</em>、<em>折半插入排序</em>和<em>希尔排序</em>。下面依次进行介绍~</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];  <span class="comment">// nums[0]哨兵，不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; nums[<span class="number">0</span>] &lt; nums[j]; --j)</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 复制nums[0]到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：最好情况O(n)，最坏情况O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)； <strong>稳定性</strong>：由于每次插入元素时总是从后往前先比较再移动，所以不会出现相等元素相对位置发生变化的情况，即直接插入排序是一种稳定的排序方法</p>
</blockquote>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; nums[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        nums[high+<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：折半插入排序仅减少了比较元素的次数，而元素的移动次数并未改变，因此时间复杂度仍为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-dk]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>]&lt;nums[j]; j -= dk)</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                nums[j+dk] = nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：n在某个特定范围内时，希尔排序时间复杂度为O(n<sup>1.3</sup>)，最坏情况下复杂度为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>所谓交换，就是指根据序列中两个元素的比较结果来对换这两个记录在序列中的位置。交换排序的算法很多，本文主要介绍冒泡排序和快速排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j<span class="number">-1</span>], nums[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;  <span class="comment">// 本趟没有发生交换，说明序列已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(n)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的一种改进，其基本思想是基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[low];  <span class="comment">// 第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) --high;</span><br><span class="line">        nums[low] = nums[high];  <span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">        nums[high] = nums[low];  <span class="comment">// 将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(nums, lowm, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(nlogn)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: 最好情况下为(logn)，最坏情况下O(n)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序基本思想是：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个。选择排序中的堆排序是考察的重点。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(nums[i], nums[min])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建立大根堆的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, i, len);  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆向下调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿k较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">            i++;                          <span class="comment">// 取k较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=nums[i]) <span class="keyword">break</span>;       <span class="comment">// 筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];            <span class="comment">// 将nums[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                        <span class="comment">// 修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>]                     <span class="comment">// 被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(nums, len);              <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>; i--) &#123;            </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span>]);           <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, <span class="number">1</span>, i<span class="number">-1</span>);         <span class="comment">// 整理，把剩下的i-1个元素整理成堆</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点执行向上调整操作。<br>下面是堆的向上调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="keyword">int</span> nums[], inr k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参数k为向上调整的节点，也为堆的元素个数</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        nums[k] = nums[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 建堆时间复杂度O(n)，每次调整时间复杂度O(h)，故在最好、最坏和平均情况下堆排序时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归形式的2路归并排序算法是基于分治的其过程如下：<br>分解：将含有n个元素的待排序表分成含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。<br>合并：合并两个已经排序的子表得到排序结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;       </span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *_copy = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt; high; k++) </span><br><span class="line">        _copy[k] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_copy[i] &lt;= _copy[j])</span><br><span class="line">            nums[k] = _copy[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = _copy[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) nums[k++] = _copy[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) nums[k++] = _copy[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 每趟归并时间复杂度为O(n)，共需logn趟归并，所以算法时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: 辅助空间占用n个单元，故空间复杂度为O(n)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华语流行乐教父罗大佑神级歌词</title>
    <url>/posts/47257.html</url>
    <content><![CDATA[<blockquote>
<p>音乐不是我一个人写的，那是所有人的“曾经”在心灵上的默契与融合，共同升华出一种年轻的感觉与驿动。每一双眼睛、每一张脸对我来讲都是不一样的，我是为了每一张不同的脸背后的故事而写歌。我希望能用音乐让整个世界、让人与人之间能够有一种心灵的交流。</p>
</blockquote>
<span id="more"></span>

<h2 id="恋曲1990"><a href="#恋曲1990" class="headerlink" title="恋曲1990"></a>恋曲1990</h2><blockquote>
<p>乌溜溜的黑眼珠<br>和你的笑脸<br>怎么也难忘记你<br>容颜的转变<br>轻飘飘的旧时光<br>就这么溜走<br>转头回去看看时<br>已匆匆数年<br>苍茫茫的天涯路<br>是你的飘泊<br>寻寻觅觅长相守<br>是我的脚步<br>黑漆漆的孤枕边<br>是你的温柔<br>醒来时的清晨里<br>是我的哀愁<br>或许明日太阳西下<br>倦鸟已归时<br>你将已经踏上<br>旧时的归途<br>人生难得再次寻觅<br>相知的伴侣<br>生命终究难舍<br>蓝蓝的白云天<br>轰隆隆的雷雨声<br>在我的窗前<br>怎么也难忘记你<br>离去的转变<br>孤单单的身影后<br>寂寥的心情<br>永远无怨的<br>是我的双眼</p>
</blockquote>
<h2 id="爱的箴言"><a href="#爱的箴言" class="headerlink" title="爱的箴言"></a>爱的箴言</h2><blockquote>
<p>我将真心付给了你<br>将悲伤留给我自己<br>我将青春付给了你<br>将岁月留给我自己<br>我将生命付给了你<br>将孤独留给我自己<br>我将春天付给了你<br>将冬天留给我自己<br><br>爱是没有人能了解的东西<br>爱是永恒的旋律<br>爱是欢笑泪珠飘落的过程<br>爱曾经是我也是你</p>
</blockquote>
<h2 id="光阴的故事"><a href="#光阴的故事" class="headerlink" title="光阴的故事"></a>光阴的故事</h2><blockquote>
<p>春天的花开秋天的风<br>以及冬天的落阳<br>忧郁的青春年少的我<br>曾经无知的这么想<br>风车在四季轮回的歌里<br>它天天地流转<br>风花雪月的诗句里<br>我在年年的成长<br>流水它带走光阴的故事<br>改变了一个人<br>就在那多愁善感而初次<br>等待的青春<br>发黄的相片古老的信<br>以及褪色的圣诞卡<br>年轻时为你写的歌<br>恐怕你早已忘了吧<br>过去的誓言就象那课本里<br>缤纷的书签<br>刻划着多少美丽的诗<br>可是终究是一阵烟<br>流水它带走光阴的故事<br>改变了两个人<br>就在那多愁善感而初次<br>流泪的青春<br>遥远的路程昨日的梦<br>以及远去的笑声<br>再次的见面我们又历经了<br>多少的路程<br>不再是旧日熟悉的我<br>有着旧日狂热的梦<br>也不是旧日熟悉的你<br>有着依然的笑容<br>流水它带走光阴的故事<br>改变了我们<br>就在那多愁善感而初次<br>回忆的青春</p>
</blockquote>
<h2 id="童年"><a href="#童年" class="headerlink" title="童年"></a>童年</h2><blockquote>
<p>池塘边的榕树上<br>知了在声声叫着夏天<br>操场边的秋千上<br>只有蝴蝶停在上面<br>黑板上老师的粉笔<br>还在拼命叽叽喳喳写个不停<br>等待着下课等待着放学<br>等待游戏的童年<br><br>福利社里面什么都有<br>就是口袋里没有半毛钱<br>诸葛四郎和魔鬼党<br>到底谁抢到那支宝剑<br>隔壁班的那个女孩<br>怎么还没经过我的窗前<br>嘴里的零食手里的漫画<br>心里初恋的童年<br><br>总是要等到睡觉前<br>才知道功课只做了一点点<br>总是要等到考试以后<br>才知道该念的书都没有念<br>一寸光阴一寸金<br>老师说过寸金难买寸光阴<br>一天又一天一年又一年<br>迷迷糊糊的童年<br><br>没有人知道为什么<br>太阳总下到山的那一边<br>没有人能够告诉我<br>山里面有没有住着神仙<br>多少的日子里总是<br>一个人面对着天空发呆<br>就这么好奇就这么幻想<br>这么孤单的童年<br><br>阳光下蜻蜓飞过来<br>一片片绿油油的稻田<br>水彩蜡笔和万花筒<br>画不出天边那一条彩虹<br>什么时候才能像高年级的同学<br>有张成熟与长大的脸<br>盼望着假期盼望着明天<br>盼望长大的童年<br><br>一天又一天一年又一年<br>盼望长大的童年 </p>
</blockquote>
<h2 id="东方之珠"><a href="#东方之珠" class="headerlink" title="东方之珠"></a>东方之珠</h2><blockquote>
<p>小河弯弯向南流<br>流到香江去看一看<br>东方之珠<br>我的爱人<br>你的风采是否浪漫依然<br>月儿弯弯的海港<br>夜色深深<br>灯火闪亮<br>东方之珠<br>整夜未眠<br>守着沧海桑田<br>变幻的诺言<br>让海风吹拂了五千年<br>每一滴泪珠<br>仿佛都说出<br>你的尊严<br>让海潮伴我来保佑你<br>请别忘记我<br>永远不变<br>黄色的脸<br><br>船儿弯弯<br>入海港<br>回头望望<br>沧海茫茫<br>东方之珠<br>拥抱着我<br>让我温暖<br>你那苍凉的胸膛</p>
</blockquote>
<h2 id="亚细亚的孤儿"><a href="#亚细亚的孤儿" class="headerlink" title="亚细亚的孤儿"></a>亚细亚的孤儿</h2><blockquote>
<p>亚细亚的孤儿<br>在风中哭泣<br>黄色的脸孔<br>有红色的污泥<br>黑色的眼珠<br>有白色的恐惧<br>西风在东方<br>唱着悲伤的歌曲<br>亚细亚的孤儿<br>在风中哭泣<br>没有人要和你<br>玩平等的游戏<br>每个人都想要<br>你心爱的玩具<br>亲爱的孩子<br>你为何哭泣<br><br>多少人在追寻<br>那解不开的问题<br>多少人在深夜里<br>无奈地叹息<br>多少人的眼泪<br>在无言中抹去<br>亲爱的母亲<br>这是什么道理<br>亲爱的母亲<br>这是什么真理</p>
</blockquote>
<h2 id="盲聋"><a href="#盲聋" class="headerlink" title="盲聋"></a>盲聋</h2><blockquote>
<p>我知道你听不到我的歌声<br>你也看不到这世界<br>也许你不了解有多少<br>愿意关怀你的人们<br>或许你早已适应了<br>黑暗的生存<br>或许你不愿接受<br>同情的滋润<br>来自庸俗的人<br><br>我知道他听得到我的歌声<br>他也看得清这世界<br>可是昨日的信仰<br>已变成了过去<br>狂热犹存的余温<br>人们欢聚在闹市里<br>喧嚣的霓虹灯<br>破落的庭院的主人<br>也成了回忆中<br>我们遗忘的人<br><br>有人因为失去了生命<br>而得到了不灭的永恒<br>有人为了生存而出卖了<br>他们可贵的灵魂<br>心中深处的天平上<br>你的欲望与真理在斗争<br>曾经一度自诩聪明的你<br>是个迷惑的人<br></p>
</blockquote>
<h2 id="现象七十二变"><a href="#现象七十二变" class="headerlink" title="现象七十二变"></a>现象七十二变</h2><blockquote>
<p>眼看着高楼盖得越来越高<br>我们的人情味却越来越薄<br>朋友之间越来越有礼貌<br>只因为大家见面越来越少<br>苹果价钱卖得没以前高<br>或许现在味道变得不好<br>就像彩色的电视变得更加花俏<br>能辨别黑白的人越来越少<br><br>是个什么样的心理因素<br>每年要吃掉一条高速公路<br>在西门町（台北）的天桥上面闲逛<br>有多少文明人在人行道上<br>就像我看到文明车辆横冲直撞<br>我不懂大家心中作何感想<br>一年过了又是新的一年<br>每一年现代都在传统边缘<br>在每个新的一年三百六十五天<br>我们都每天进步一点点</p>
</blockquote>
<h2 id="稻草人"><a href="#稻草人" class="headerlink" title="稻草人"></a>稻草人</h2><blockquote>
<p>终日面对着青山<br>终日面对着稻浪<br>午后的云雀背着艳阳<br>那样飞<br>那样笑<br>那样歌唱<br>轻风吹在我身上<br>雨珠打在我脸上<br>午后的牛羊凝向远方<br>彩虹画出的希望<br><br>蓝蓝的青空在上<br>却有着云雀与彩虹的梦<br>多像不知足的云四处飘荡<br>何处是我的归宿<br>是否在天际的那一端<br>奇怪着稻草的身躯如何飞翔<br><br>终日面对着青山<br>终日面对着稻浪<br>晨光<br>露珠<br>夕阳<br>星辰<br>春耕<br>秋收<br>冬藏</p>
</blockquote>
<h2 id="牧童"><a href="#牧童" class="headerlink" title="牧童"></a>牧童</h2><blockquote>
<p>牛背上的牧童<br>敞开你的胸扉<br>三月的苍茫<br>掩不住你树影下菊色的梦<br>风在林梢叹息<br>云在碧空飘逸<br>你冷漠的笛声<br>掠过青草带来泥土的芳香<br>九月的诗<br>早已埋藏在风雪之中<br>为何我听到<br>你胸口里热血汹涌<br>你看那<br>千古的泉水在山谷回旋<br>可知道<br>青鸟在树林呼唤你<br>牧童<br>田园已经荒芜<br>斜阳依然孤独<br>且让你的冷漠<br>投影在那泼墨残痕的归途</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>音乐</category>
        <category>罗大佑</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/posts/43432.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第七章】</strong>天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先，外其身而身存。非以其无私邪（yé）？故能成其私。</p>
</blockquote>
<span id="more"></span>
<h2 id="【哲学家的狂欢】上帝已死，哲学永生"><a href="#【哲学家的狂欢】上帝已死，哲学永生" class="headerlink" title="【哲学家的狂欢】上帝已死，哲学永生"></a>【哲学家的狂欢】上帝已死，哲学永生</h2><blockquote>
<p>上帝死了，但是人类会构筑一个千年不坏的山洞，在山洞里人们会展示他的形象。<br>——弗里德里希·威廉·尼采《快乐的知识》<br>（小字:上帝应当被杀死，并已经被杀死，他死于对人类的怜悯。怜悯是钉死爱人着的十字架。）<br>“别的小伙子都为了保卫文明穿上军装打仗去了，你就不惭愧么？”<br>“我就是他们要保卫的那种文明。”<br>——伯特兰·罗素（分析哲学的主要创始人）<br>“怀疑一切:我可以怀疑一切，但我却不能怀疑我正在怀疑。”<br>“我思故我在！”<br>——勒内·卡迪尔（法国哲学家）<br>（小字:永远只求克服自己，不求克服命运，只求改变自己的愿望，不求改变世间的秩序。）<br>如果不是我配不上这个时代，那就是这个时代配不上我。<br>——亚瑟·叔本华（德国著名哲学家）<br>（小字:一个人只有在独处时才能成为自己，因为一个人只有在独处时才是真正自由的。）<br>位我上者，灿烂星空，道德律令，在我心中。<br>——伊曼努尔·康德（古典哲学创始人）<br>（小字:我是孤独的，我是自由的，我是我自己的帝王。）<br>一个哲学家对自己的起码要求和最高要求是什么？<br>“在自己身上克服他的时代，成为无时代的人。”<br>——弗里德里希·威廉·尼采《瓦格纳事件》<br>（小字:世界弥漫着焦躁不安的气息，因为每一个人都急于从自己的枷锁中解放出来。）<br>离群索居者，不是野兽，便是神灵。<br>——亚里士多德《政治学》<br>（小字:野兽独居，因为他桀骜不驯。天神独居，因为他充实自足，然而，哲学家必须同时是两者。）<br>向死而生的意义是:当你无限接近死亡，才能深切体会生的意义。<br>——马丁·海德格尔（德国哲学家）<br>（小字:充满劳绩，然而人，诗意地栖居在大地之上。）<br>按照你所知道的最善的方式去生活。<br>——苏格拉底（古希腊哲学家）<br>（小字:在这个世界上，除了阳光，空气，水和笑容，我们还需要什么呢？）<br>若没有国家，没有政府，世界将是每一个人与每一个人的战争。<br>——托马斯·霍布斯（英国哲学家）<br>（小字:人在自然状态下总是处于自然状态，每个人对一切事物的自然权利会导致战争。）<br>当世界上最后一个爱国者死去的时候，和平就到来了。<br>——伯兰特·罗素（分析哲学的主要创始人）<br>那些许诺我们人间天堂的家伙，除了地狱什么也没搞出来。<br>——卡尔·波普尔（犹太商哲学家）<br>（小字:企图缔造人间天堂的结果无一例外造成人间地狱，它导致不宽容。） ​</p>
</blockquote>
<h2 id="叔本华"><a href="#叔本华" class="headerlink" title="叔本华"></a>叔本华</h2><blockquote>
<p>我们读书时，是别人在代替我们思想，我们只不过重复他的思想活动的过程而已，犹如儿童启蒙习字时，用笔按照教师以铅笔所写的笔画依样画葫芦一般。我们的思想活动在读书时被免除了一大部分。因此，我们暂不自行思索而拿书来读时，会觉得很轻松，然而在读书时，我们的头脑实际上成为别人思想的运动场了。所以，读书愈多，或整天沉浸读书的人，虽然可借以休养精神，但他的思维能力必将渐次丧失，此犹如时常骑马的人步行能力必定较差，道理相同。<br><br>生命是一团欲望，欲望不能满足便痛苦，满足便无聊，人生就在痛苦和无聊之间摇摆。<br><br>一个人只有在独处时才能成为自己。谁要是不爱独处，那他就不爱自由，因为一个人只有在独处时才是真正自由的。<br><br>社交聚会要求人们做出牺牲，而一个人越具备独特的个性，那他就越难做出这样的牺牲。因此，一个人逃避、忍受抑或喜爱独处是和这一个人自身具备的价值恰成比例。因为在独处的时候，一个可怜虫就会感受到自己的全部可怜之处，而一个具有丰富思想的人只会感觉到自己丰富的思想。<br><br>学会在人群中保持一定程度上的孤独，不要有什么想法就立马告诉别人。另外，对别人所说的话千万不要太过当真。不能对别人有太多的期待，无论在道德上抑或在思想上。对于别人的看法，应锻炼出一副淡漠、无动于衷的态度，因为这是培养值得称道的宽容的一个最切实可行的手段。<br></p>
</blockquote>
<h2 id="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"><a href="#知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？" class="headerlink" title="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"></a>知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？</h2><blockquote>
<p>很多人意识不到，头顶的星空，才是生命最终极的意义所在，而我们的生活，不过是附属品而已。<br><br>低头看看你的手上的皮肤，上面的某一个原子，它来自你几天前吃下的一块牛肉，那头牛吃过一根草，这根草吸收了一片草原中的某些成分，这些成分是被一座远古火山喷出来的，那座火山喷出的都是地球内部的岩浆，这些岩浆在地球形成之前只是太阳系中的粉尘，这些粉尘来自一片星云，这片星云则来自太阳的前身星——一颗蓝巨星——垂死时产生的超新星爆发。而这颗蓝巨星诞生于更早的几亿年之前的第二代恒星死亡后的遗骸中，一直追朔到宇宙刚诞生的时候，所有这些东西都是一些夸克、胶子….你身体中所有大于铁的原子，都诞生于某颗超新星生命的最后时刻。<br><br>所以，说我们是星空的孩子，那是一点都不错的。可是你看看现在的人们，从他们的意识中，找得到一点和这有关的东西吗？找不到。人们只会关心当下的事，因为这和自己的切身利益直接相关，人们关心钱，关心亲人、爱人，关心工作，关心房价，关心友情，关心天气，将所有人类大脑与人类社会相互交杂后的必然产物掰开揉碎了分析得入木三分，然后按一种似乎是约定俗成的规则去做对自己最有利的事，将生活这一概念放大到无限大，占据了一个人内心的全部。<br><br>在这样一种大环境中，在某个晴朗无云的夜晚，在某个远离城市的静谧草原，你抬起头，一片明亮、壮丽、优雅、安详、神秘的广阔星空如一张巨幕赫然呈现在眼前，如一丝清雨将你世俗的双眼洗刷得干净透彻，什么都不剩，你与你最本质的归属之间再无任何隔阂，只有不断涌入眼中的无数星光直接打入你的内心。你怎能不感动？怎能不幸福？怎能不惊叹于世界之外这超越一切的最终极的美？这时你才意识到，你是社会的，但首先是自然的。<br><br>作者：<a href="https://www.zhihu.com/question/28006748/answer/39013684">萤火一号：</a><br><br>来源：知乎</p>
</blockquote>
<h2 id="刘慈欣"><a href="#刘慈欣" class="headerlink" title="刘慈欣"></a>刘慈欣</h2><h3 id="《球状闪电》"><a href="#《球状闪电》" class="headerlink" title="《球状闪电》"></a>《球状闪电》</h3><blockquote>
<p>“从物理学角度看，生命这种物质运动形式，与其他的物质运动相比并没有更高的含义，从生命中你找不到新的物理规律，所以从我的角度看，一个人的死与一块冰的消融并没有本质的区别。陈博士，你这人有时候想得太多，你应该学会从宇宙终极规律的角度看待生活，这样过得就舒服多了。”（这比宗教还超脱…）<br><br>后来发现，整个物理学就像是一个大谜，走到它的尽头，连整个世界是否存在都成了问题。<br><br>美妙人生的关键在于你能迷上什么东西。<br> <br>理想主义者和玩世不恭的人都觉得对方很可怜，可他们实际都很幸运。<br><br>“其实，儿子，过一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好是只用一张纸和一只铅笔的数学难题，比如歌德巴赫猜想或费尔马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。人们常说的寄托，也就是这么回事。或是相反，把挣钱作为惟一的目标，所有的时间都想着怎么挣，也不问挣来干什么用，到死的时候像葛朗台一样抱者一堆金币说：啊，真暖和啊……所以，美妙人生的关键在于你能迷上什么东西。”（窃以为，绝大多数时候这种人生并不美妙…）<br><br>黄金色的树林里分出两条路，可惜我们不能同时去涉足，但我们却选择了人迹罕至的那一条，这从此决定了我们的一生。<br><br>“我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳……它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。<br>　　<br>当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。” </p>
</blockquote>
<h3 id="《三体》"><a href="#《三体》" class="headerlink" title="《三体》"></a>《三体》</h3><blockquote>
<p><strong>《三体1：地球往事》</strong><br>我们都是阴沟里的虫子,但总还是得有人仰望星空。<br>　　<br>“我只想说明以下的事实：在宇宙间，一个技术文明等级的重要标志，是它能够控制和使用的微观维度。对于基本粒子的一线使用，从我们那些长毛裸体的祖先在山洞中生起篝火时就开始了，对化学反应的控制，就是在一维层次上操控微观粒子。当然，这种控制也是从低级到高级，从篝火到后来的蒸汽机，再到后来的发电机；现在，人类对微观粒子一维控制的水平已达到了顶峰，有了计算机，也有了你们的纳米材料。但这一切，都局限于对微观维度的一维控制，在宇宙间一个更高级的文明看来，篝火和计算机、纳米材料等等是没有本质区别的，同属于一个层次，这也是他们仍将人类看成虫子的原因——遗憾的是，他们是对的。” <br><br>消灭人类暴政！世界属于三体！（源于阿尔巴尼亚电影《地下游击队》游击队员的那句“消灭法西斯，自由属于人民”）。<br><br> “射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律： “宇宙每隔十厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙中的铁律。<br><br>“农场主假说”：则有一层令人不安的恐怖色彩：一个农场里有一一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙中的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。<br><br><strong>《三体2：黑暗森林》</strong><br>“这是计划的一部分。”<br><br>第一，生存是文明的第一需要；第二，文明不断增长和扩张，但宇宙中的物质总量保持不变。<br><br> “要多想。”父亲说。<br>“想了以后呢？”章北海问。<br>“北海，我只能告诉你那以前要多想。”父亲回答。<br>爸，谢谢您。您说得很清楚了，我的心都听懂了。 <br><br> 大低谷纪念碑：给岁月以文明，而不是给文明以岁月。（给时光以生命，而不是给生命以时光——-帕斯卡） <br><br>“这…也太黑了吧…”“真实的宇宙就是这么黑。”罗辑伸手挥挥，像抚摸天鹅缄般感受着黑暗的质感，“宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼…他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男神，能做的只有一件事：开枪消灭之！在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。”大史又点上了一支烟，仅仅是为了有点光明。<br><br>“但黑暗森林中有一个叫人类的傻孩子，生了一堆火并在旁边高喊：我在这儿！我在这儿！”罗辑说。<br><br><strong>《三体3：死神永生》</strong><br>死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。（如果一切都逝去了，死神的永生还有意义吗？）<br><br>前进！前进,不择手段地前进！——维德<br><br>“不要返航！这里不是家！” <br><br>维德抬头看着程心，目光中又露出了那种罕见的无助和乞求，他一字一顿地说：“失去人性，失去很多；失去兽性，失去一切。”（伟大导师恩格斯曰：人类源于动物的事实决定了人类永远不可能摆脱兽性，只是在于摆脱的多与少而已。）<br><br>低熵体不一样，低熵体的熵还在降低.有序度还在上升，像漆黑海面上升起的磷火,这就是意义，最高层的意义，比乐趣的意义层次要高。要维持这种意义，低墒体就必须存在和延续。（它的意义在于没意义…）<br><br>藏好自己，做好清理。<br><br>弱小和无知不是生存的障碍,傲慢才是。<br><br>把海弄干的鱼在海干前上了陆地，从一片黑暗森林奔向另一片黑暗森林。<br><br><a href="https://www.bilibili.com/read/cv855892/">注释作者：张北海 </a> </p>
</blockquote>
<h2 id="《哲学九讲》节选"><a href="#《哲学九讲》节选" class="headerlink" title="《哲学九讲》节选"></a>《哲学九讲》节选</h2><blockquote>
<p>对于唯物主义，不管是哪种形式的唯物主义，一元论还是多元论，我们必须指出的是，物质性本体的观点到最后只能是精神上的自杀。如果构成整个宇宙的都是无意识的东西，那么我们称之为思想的东西以及思想活动，如果不能算是纯粹的物质，就只能是和热量、运动一样，作为其他物质实体的一种表现。思想与热量和运动将毫无差别，同样，我们也没有理由认为思想比温度或速度更重要。如果说思想只是某个物质实体一系列性质的表现，那它在物质上的意义就将等同于热量，而在精神上，则没有任何意义。而其所有成果，包括唯物主义本身在内，都将毫无意义，也毫无作用可言了。如果思想只是物质状态的产物，那么也就不会有什么至高无上的真理和唯物主义理论是否正确这样的问题了。所有的东西都只是像冰、水和水蒸气一样的存在，说唯物主义比唯心主义更正确，就好比说冰比水蒸气更真实一样没有意义，因为连真理这个词都是没有意义的。怀疑论者陷入了这么一个困境：如果他要否认所有观点和我们寻求真理的可能性，那他就必须同时否认支撑他去怀疑的观点，以及他意识到自己观点正确性的可能。而唯物主义者面临的困境也同样严峻。</p>
</blockquote>
<h2 id="虞美人·听雨"><a href="#虞美人·听雨" class="headerlink" title="虞美人·听雨"></a>虞美人·听雨</h2><blockquote>
<p>虞美人·听雨<br>蒋捷 〔宋代〕<br>少年听雨歌楼上，红烛昏罗帐。壮年听雨客舟中，江阔云低、断雁叫西风。<br>而今听雨僧庐下，鬓已星星也。悲欢离合总无情，一任阶前、点滴到天明。</p>
</blockquote>
<h2 id="李晓鹏"><a href="#李晓鹏" class="headerlink" title="李晓鹏"></a>李晓鹏</h2><h3 id="哲学的产生"><a href="#哲学的产生" class="headerlink" title="哲学的产生"></a>哲学的产生</h3><h3 id="《从黄河文明到一带一路·第四卷》"><a href="#《从黄河文明到一带一路·第四卷》" class="headerlink" title="《从黄河文明到一带一路·第四卷》"></a>《从黄河文明到一带一路·第四卷》</h3><blockquote>
<p>犹太教、基督教、拜上帝教都认上帝为唯一主神，但上帝分别派了三个人来干三件不同的事：一是委托摩西管理和拯救犹太民族；二是委托耶稣来净化人类的灵魂；三是委托洪秀全来拯救中国人民。<br><br>近代中国的革命和改良，基本主线是中国人民与满清、汉族官僚士绅、外国列强三股反动势力反复博弈的过程。太平天国试图以底层革命的方式一次性推翻三大反动势力，壮烈失败。此后，满洲和汉族官僚士绅联合起来搞“洋务运动”，想以此富国强兵、抵御外辱，以甲午惨败结束。然后，义和团运动试图采取“扶清灭洋”的路线，联合国内两股势力共同抵御列强，遭到了汉族官僚的拒绝和满清的背叛，又被三大反动势力联合镇压。《辛丑条约》以后，满清全面投靠列强，倚靠列强榨取汉族士绅和中国人民的利益，结果就是汉族官僚士绅们开始跟革命党合作，以谋求终结满清专制，最终诱发了辛亥革命。</p>
</blockquote>
<h3 id="《从黄河文明到一带一路·第三卷》"><a href="#《从黄河文明到一带一路·第三卷》" class="headerlink" title="《从黄河文明到一带一路·第三卷》"></a>《从黄河文明到一带一路·第三卷》</h3><blockquote>
<p>投票式民主并不是英国的首创，雅典和威尼斯共和国这些古老的海权国家，都是搞的投票式民主。这三个时期的代表性海权国家，都主要依靠海外殖民劫掠发迹。由于它们有大量来自于海外殖民地的财富，本国内部的生存资源争夺并不激烈。其本国底层人民，也可以从海外殖民带来的财富中获利，而无需向中国古代的农民一样，完全依靠自己的努力来养活自己和整个国家。在生存资源无忧的情况下，内部斗争——不管是统治阶级内部的利益集团之间的斗争，还是统治阶级与被统治阶级之间的斗争，都会相对缓和。也就不需要一个专制君主来决定资源分配，大多数问题用投票和开会的形式也能解决。这种民主体制，本质上是一种“分赃式民主”，是强盗们为了和平分配劫掠而来的财富所建立的程序。哲学的产生需要有两个条件。第一个条件是人的认识能力和自我意识有了提高，开始把人看成主动的存在，看成认识世界的主体，不再把自己看成被动的存在，看成神的依附者。第二个条件是社会上出现了专门从事精神创造的知识阶层，他们不必从事生产劳动，衣食无忧，有充分的时间去思考哲学问题。<br><br>英国从君主专制国家走向君主立宪制国家的背景就是这样。专制时期，还没有建立海外殖民霸权，全体国民必须自己养活自己，在国家内部分配生存资源。这个时候要组织国家资源打仗，不管是殖民战争还是争霸战争，就会面临非常严峻的国内生存资源分配问题。为了保证战争的效率和分配的公平，最佳的方案就是建立独裁君主制度。独裁君主有两个作用，一个是镇压人民反抗，但还有一个很重要的作用，就是遏制贵族的贪欲，限制他们对人民的剥夺，并强迫贵族、地主、资本家这些有钱有权的阶层多出钱来支持战争。用独裁君主制代替封建制度，是英国从弱到强的关键。等到殖民战争和争霸战争打赢了，最艰难的时刻过去了，殖民统治体系建立起来了，有众多海外殖民地可供掠夺，资源分配条件变得宽松。利益集团内部，不需要进行你死我活的斗争了；统治精英们富得流油的同时，底层人民的税负也不高、福利还不错。这种情况下，专制君主就成了一个累赘。大家就觉得还是民主好，独裁君主对贵族精英们管束的太严了、收的钱太多了，让精英们很不舒服，可以搞个科学的程序来做决策，各大利益集团选择自己的代表大家开个会各抒己见就挺好的。贵族、地主、资本家就联合起来把专制君主推翻了。决策程序慢一点没关系，吵架厉害一点没关系，不会耽误大事，利益集团之间也不会当真打起来，代议制民主就取代了独裁君主制。</p>
</blockquote>
<h3 id="人治和法治"><a href="#人治和法治" class="headerlink" title="人治和法治"></a>人治和法治</h3><blockquote>
<p>一些迷信西方制度优越论的人，还进一步提出了所谓“人治”和“法治”的争议。他们认为中国的皇帝制度是人治，而西方的立宪制度是法治，法治是天生优于人治的。这种说法是不正确的，生造出一个概念将这两种制度对立起来，忽略了它们之间的共性和传承关系。一切法律都是人制定、修改并执行的，无论东方还是西方，古代还是现代，世界上都没有“法治社会”这种社会形态。<br><br>君主专制制度并不是君主决定每一件事情，它背后也是一套意识形态的法制体系作为支撑。中华帝国的每个王朝都有一套相当庞大而复杂的法律体系来支持其日常运转，对这一点有疑问的人可以读一下国内任何一个法学院的《中国法制史》教材。民众面对各种违法犯罪行为，也会下意识的问一句：“还有没有王法？”法律意识普及性很高。这里面当然存在有法不依、胡乱执法等问题，但这是任何制度下都有的问题，且其严重程度并不由制度本身决定，而跟收入水平、就业率、贫富差距、技术水平等相关，越是技术落后交通通讯不便的古代社会，执法者的违规成本越低，越容易胡乱执法；此外，它还跟统治精英距离大规模战争“换血”的时间密切相关，一般来说，时间越长，问题就越严重。<br><br>宪政民主制度也不是每一件事情都由全民投票表决，背后有无数的人在职业化的对其操纵，在美国式三权分立体制下，法官和律师勾结、官员与商人勾结、总统收钱赦免“关系户”等行为屡见不鲜，立法者受利益集团操控在法律中大量植入维护利益集团的条款，更是司空见惯。<br><br>皇帝制度和西方宪政制度的差距，主要是法律制定程序的区别，在有没有法律和法律如何执行方面，则没有很大区别。利益集团一旦掌握了制定法律和执行法律的权力，法律就很难对他们构成真正的约束，这个集团的行动自由就跟皇帝和皇族差不多了。哪怕让人工智能程序来执法，统治精英们也可以悄无声息的在程序代码中写入对自己有利的漏洞，确保该程序作出有利于自己的裁决。一切法治，皆为人治；一切人治，皆有法治——没有成文法，也有习惯法。<br><br>“人治”和“法治”的争议，是一个伪问题。中国是人治或人情社会、西方是法治社会之类的说法，都是自欺欺人之言。迄今为止的一切人类文明社会形态都是人治社会，也都有法制和法治意识。人治和法制是两个层面的东西，互相之间并不矛盾，可以共同存在，而高于人治的法治则是一个臆想出来的在现实中并不存在的概念。</p>
</blockquote>
<h2 id="历史周期律"><a href="#历史周期律" class="headerlink" title="历史周期律"></a>历史周期律</h2><blockquote>
<p>历史课本告诉我们：中国封建社会存在着互相对立、彼此消长的两种土地所有制: 一是封建地主土地所有制( 包含地主阶级的国有土地制) ， 一是农民小块土地所有制。前者占支配地位， 后者为其补充。这样中国封建土地所有制实质就是封建地主土地所有制， 基本特点是土地所有权高度集中在地主阶级手中。小农经济具有其抗风险能力差的特点，普通农户家庭一旦遇到水旱蝗灾、年景歉收或是婚丧嫁娶、疾病，就不得不以土地作为抵押，从地主乡绅那里获取高利贷。<br><br>然而就像马克思和无数学者所证明的那样，历来资本的边际收益要高于劳动的边际收益，因此这就注定了在许多情况下，农民辛苦劳作所取得的收益是无法偿还高利贷的利息的。这样就在利息的“驴打滚”中恶性循环，直至将被抵押的土地偿还给地主，成为佃农，更惨一点的，就是流民。万历年间一份奏折指出：“或因水旱饥荒，及粮差繁并，或被势要相侵，及钱债驱迫，不得已将起科腴田，减其价直，典卖……”。相关的文学作品可以参考《白毛女》和茅盾先生的《春种》《秋收》。<br><br>然而，问题就来了，地主兼并农民土地，是一个线性增长财富集中愈演愈烈的趋势，但是问题就来了，因为地主士绅兼并的这些土地是不向国家交税的：<br><br>这就是造成中国封建王朝兴衰周期律的根本原因之一。土地越来越多地集中在特权阶层手中，国家能得到的赋税也就越来越少；另一方面失地流民越来越多，镇压、安抚农民起义又需要大量的财政收入，这对于封建王朝来说是一个死局。土地越集中在这些特权阶层的手中，国家受到的利益损失就越大，这就是历史上的所谓“ 锄豪强， 抑兼并”的经济思想和政策产生的经济根源。但是从公元前七年汉哀帝绥和二年颁布的封建史上的第一次限田令以来， 诸如王莽的王田制、晋初的占田制、北魏的均田制等等， 无不在既得利益的缙绅、官僚、豪强的反对下，成为一纸空文，不能实施。<br><br>来源：微信公众号”大浪淘沙”</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
        <category>哲学/历史</category>
      </categories>
      <tags>
        <tag>哲学/历史</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/posts/45955.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第八章】</strong>上善若水。水善利万物而不争，处众人之所恶（wù），故几（jī）于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p>
</blockquote>
<span id="more"></span>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p>
<h2 id="线索二叉树结构"><a href="#线索二叉树结构" class="headerlink" title="线索二叉树结构"></a>线索二叉树结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag; <span class="comment">// 左、右线索标志：0：孩子；1：前驱</span></span><br><span class="line">    <span class="built_in">ThreadNode</span>(<span class="keyword">int</span> x) : <span class="built_in">data</span>(x), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>), <span class="built_in">ltag</span>(<span class="number">0</span>), <span class="built_in">rtag</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ThreadNode* ThreadTree;</span><br></pre></td></tr></table></figure>

<h2 id="中序线索化二叉树"><a href="#中序线索化二叉树" class="headerlink" title="中序线索化二叉树"></a>中序线索化二叉树</h2><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;lchild, pre);  </span><br><span class="line">    <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;  </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;rchild, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树"><a href="#建立线索化二叉树" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点"><a href="#求第一个节点" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild; <span class="comment">// 最左下节点，不一定是叶节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点"><a href="#求后继节点" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// rtag=1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的中序线索二叉树的中序遍历"><a href="#不含头结点的中序线索二叉树的中序遍历" class="headerlink" title="不含头结点的中序线索二叉树的中序遍历"></a>不含头结点的中序线索二叉树的中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序线索化二叉树上实现前序遍历的算法"><a href="#中序线索化二叉树上实现前序遍历的算法" class="headerlink" title="中序线索化二叉树上实现前序遍历的算法"></a>中序线索化二叉树上实现前序遍历的算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);  <span class="comment">// 先访问根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;ltag == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 有左子树，即为后继</span></span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;rtag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有柚子树，即为后继</span></span><br><span class="line">            node = node-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无左右子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;rtag==<span class="number">1</span>) <span class="comment">// 检测后继线索 直到找到有右子树的结点</span></span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node =node-&gt;rchild;  <span class="comment">//该结点的右子树为后继</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前序线索化二叉树"><a href="#前序线索化二叉树" class="headerlink" title="前序线索化二叉树"></a>前序线索化二叉树</h2><h3 id="前序线索化"><a href="#前序线索化" class="headerlink" title="前序线索化"></a>前序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">PreThread</span>(p-&gt;lchild, pre);    </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">PreThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树-1"><a href="#建立线索化二叉树-1" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;  <span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点-1"><a href="#求第一个节点-1" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点-1"><a href="#求后继节点-1" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// rtag=1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的前序线索二叉树的前序遍历"><a href="#不含头结点的前序线索二叉树的前序遍历" class="headerlink" title="不含头结点的前序线索二叉树的前序遍历"></a>不含头结点的前序线索二叉树的前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序线索化二叉树"><a href="#后序线索化二叉树" class="headerlink" title="后序线索化二叉树"></a>后序线索化二叉树</h2><h3 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">PostThread</span>(p-&gt;lchild, pre);    </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">PostThread</span>(p-&gt;rchild, pre);</span><br><span class="line">        <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树-2"><a href="#建立线索化二叉树-2" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T, pre);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点-2"><a href="#求第一个节点-2" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    TreeNode *p = T;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;lchild || p-&gt;rchild) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild) &#123;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求父节点"><a href="#求父节点" class="headerlink" title="求父节点"></a>求父节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Parent</span><span class="params">(TreeNode* node, ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span> || T==<span class="literal">nullptr</span> || node==T) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==node || T-&gt;rchild==node) </span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">Parent</span>(node, T-&gt;lchild);</span><br><span class="line">    TreeNode *right = <span class="built_in">Parent</span>(node, T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> left==<span class="literal">nullptr</span> ? right : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点-2"><a href="#求后继节点-2" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回后序线索二叉树后继结点，如果rtag=0，则返回当前节点父节点的FirstNode</span></span><br><span class="line"><span class="comment">        如果父节点无右子树，则返回父节点本身，即左孩子后继为父节点*/</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(<span class="built_in">Parent</span>(p));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的后序线索二叉树的后序遍历"><a href="#不含头结点的后序线索二叉树的后序遍历" class="headerlink" title="不含头结点的后序线索二叉树的后序遍历"></a>不含头结点的后序线索二叉树的后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/posts/39893.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第九章】</strong>持而盈之，不如其已。揣(chuǎi)而锐之，不可长保。金玉满堂，莫之能守。富贵而骄，自遗（yí）其咎。功成身退，天之道。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法模板框架"><a href="#算法模板框架" class="headerlink" title="算法模板框架"></a>算法模板框架</h2><blockquote>
<p>滑动窗口算法的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。这里总结一套滑动窗口算法的通用模板：<br><br>来源：labuladong的算法小抄</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SlideWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/*********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode题目"><a href="#leetcode题目" class="headerlink" title="leetcode题目"></a>leetcode题目</h2><h3 id="74-最小覆盖子串"><a href="#74-最小覆盖子串" class="headerlink" title="74.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">74.最小覆盖子串</a></h3><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “”。<br>滑动窗口解法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">   unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, maxlen = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(valid &gt;= need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; maxlen) &#123;</span><br><span class="line">                maxlen = right - left;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen==INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3><blockquote>
<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br><br>换句话说，s1 的排列之一是 s2 的 子串 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left &gt;= s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br><br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        window[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(window.<span class="built_in">count</span>(d)) </span><br><span class="line">                window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>滑动窗口算法的思路是这样：<br>1.我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。<br>2.我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>3.此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>4.重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>这个思路其实也不难，第 2 步相当于在寻找一个<strong>可行解</strong>，然后第 3 步在优化这个<strong>可行解</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微软CSS三面凉经</title>
    <url>/posts/39426.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十章】</strong>爱民治国，能无知（zhì）乎？天门开阖（hé），能无雌乎？明白四达，能无为乎？生之、畜（xù）之，生而不有，为而不恃，长（zhǎng）而不宰，是谓玄德。</p>
</blockquote>
<span id="more"></span>

<h2 id="一面（220307上午）"><a href="#一面（220307上午）" class="headerlink" title="一面（220307上午）"></a>一面（220307上午）</h2><h3 id="英文自我介绍"><a href="#英文自我介绍" class="headerlink" title="英文自我介绍"></a>英文自我介绍</h3><p>教育背景，专业技能，为什么来微软，为什么选CSS<br>本来准备了英语介绍，结果没背熟，，，硬着头皮说完了，看面试官表情当时感觉就无了</p>
<h3 id="专业问题"><a href="#专业问题" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li>OSI七层模型是什么，每层分别介绍一下</li>
<li>Http和Https区别</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>静态成员、非静态成员区别，在内存哪个区</li>
<li>指针变量占多少空间</li>
<li>说说析构函数</li>
<li>C++动态内存分配方法</li>
<li>头文件作用</li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>进程、线程区别</li>
<li>线程调度的时机</li>
</ul>
<h2 id="二面（220307下午）"><a href="#二面（220307下午）" class="headerlink" title="二面（220307下午）"></a>二面（220307下午）</h2><h3 id="中文自我介绍"><a href="#中文自我介绍" class="headerlink" title="中文自我介绍"></a>中文自我介绍</h3><p>对CSS了解吗，为什么选CSS</p>
<h3 id="专业问题-1"><a href="#专业问题-1" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h4><ul>
<li>Http和Https区别</li>
<li>Https如何work</li>
</ul>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul>
<li>介绍下用户空间、内核空间，用户态如何切内核态</li>
<li>static关键字</li>
</ul>
<h4 id="Role-Play"><a href="#Role-Play" class="headerlink" title="Role Play"></a>Role Play</h4><p><strong>英文场景题</strong>面试官是客户（老外），将网站部署在Microsoft云平台上，突然宕机了。全程英文来交流~ 然后就是大型翻车现场。。。</p>
<h2 id="三面（220309上午）"><a href="#三面（220309上午）" class="headerlink" title="三面（220309上午）"></a>三面（220309上午）</h2><ul>
<li>自我介绍</li>
<li>对CSS的理解，如何了解客户需求，帮助客户解决问题</li>
<li>自我职业规划</li>
<li>对云计算的理解（面试官是Azure部门的）</li>
<li>英文场景题，客户web server 宕机，要求今天解决，你如何回复（英文）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次微软面试经历，值得吸取的教训还是很多的</p>
<ul>
<li>首先因为第一次面试，可能略有紧张。自我介绍都翻车了。。。</li>
<li>八股文问的不深，但是细节还是没掌握。比如表示层会话层之前只是走马观花看了一下，结果现场想不起来了，和面试官大眼瞪小眼</li>
<li>认识到自己还有很多不足（英文口语、表达能力、应变能力等），以后要谨言慎行、谦虚谨慎、戒骄戒躁了~</li>
</ul>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
        <category>Microsoft</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode链表</title>
    <url>/posts/6854.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十二章】</strong>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋（tián）猎令人心发狂，难得之货令人行妨。是以圣人为腹不为目，故去彼取此。</p>
</blockquote>
<span id="more"></span>

<h2 id="链表结构定义"><a href="#链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>本题有两种解决思路，一种递归一种迭代，思路都很精巧，下面来一一介绍：</p>
</blockquote>
<h3 id="1、递归解法"><a href="#1、递归解法" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表为空；head指向尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代解法"><a href="#2、迭代解法" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><h4 id="迭代解法一（带dummy结点）"><a href="#迭代解法一（带dummy结点）" class="headerlink" title="迭代解法一（带dummy结点）"></a>迭代解法一（带dummy结点）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *_next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = cur;</span><br><span class="line">        cur = _next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代解法二（不带dummy结点）"><a href="#迭代解法二（不带dummy结点）" class="headerlink" title="迭代解法二（不带dummy结点）"></a>迭代解法二（不带dummy结点）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LisNode *next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><blockquote>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置  left 到位置 right 的链表节点，返回 反转后的链表。</p>
</blockquote>
<h3 id="1、递归解法-1"><a href="#1、递归解法-1" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        successor = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseN</span>(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、迭代解法-1"><a href="#2、迭代解法-1" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode *pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left<span class="number">-1</span>; i++) </span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *cur = pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *a = head, *b = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">revList</span>(a, b);</span><br><span class="line">    a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">revList</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = a;</span><br><span class="line">    <span class="keyword">while</span>(cur != b) &#123;</span><br><span class="line">        ListNode *nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。<br>如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<h3 id="1、递归解法-2"><a href="#1、递归解法-2" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">traverse</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">traverse</span>(right-&gt;next);</span><br><span class="line">    res = res &amp;&amp; (left-&gt;val == right-&gt;val);</span><br><span class="line">    left = left-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代解法-2"><a href="#2、迭代解法-2" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在2；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *last = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next) &#123;</span><br><span class="line">        ListNode *t = last-&gt;next;</span><br><span class="line">        last-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *pre = head, *post = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(post != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val != post-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(list1) cur-&gt;next = list1;</span><br><span class="line">    <span class="keyword">if</span>(list2) cur-&gt;next = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h2><blockquote>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在3；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。 如果两个链表不存在相交节点，返回 null 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *pa = headA, *pb = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">length</span>(headA);</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="built_in">length</span>(headB);</span><br><span class="line">    <span class="keyword">if</span>(la &gt; lb) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = la - lb;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pa = pa-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = lb - la;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa == pb) <span class="keyword">return</span> pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode* list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    ListNode* cur = list;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *slow = dummy;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *t = slow-&gt;next;</span><br><span class="line">    slow-&gt;next= slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur-&gt;next = t;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next) pq.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/classic/problems/sort-list/description/">148. 排序链表</a></h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow = head, *fast = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* half1 = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode* half2 = <span class="built_in">sortList</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(half1, half2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/classic/problems/odd-even-linked-list/description/">328. 奇偶链表</a></h2><blockquote>
<p>定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。<br>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。<br>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode *evenHead = head-&gt;next;</span><br><span class="line">    ListNode *odd = head, *even = evenHead;</span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU\LFU缓存</title>
    <url>/posts/13455.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十三章】</strong>宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患！</p>
</blockquote>
<span id="more"></span>

<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h2><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存约束的数据结构。<br>实现 LRUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 刚访问过的结点移动到链表头</span></span><br><span class="line">        lst.<span class="built_in">splice</span>(lst.<span class="built_in">begin</span>(), lst, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> m[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// key已经存在，抹去</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>()) lst.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">        <span class="comment">// 插入链表头</span></span><br><span class="line">        lst.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="comment">// 建立key到list迭代器的映射</span></span><br><span class="line">        m[key] = lst.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 元素个数超过缓存容量大小</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt; cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = lst.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            <span class="comment">// 删除链表末尾（最近最少使用）元素</span></span><br><span class="line">            lst.<span class="built_in">pop_back</span>();</span><br><span class="line">            m.<span class="built_in">erase</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;  </span><br><span class="line">    <span class="comment">// 链表，元素为（key，value）对</span></span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; lst;</span><br><span class="line">    <span class="comment">// 哈希表，key--&gt;（key，value）迭代器</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></h2><blockquote>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。<br>实现 LFUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 将结点从freq list里摘除</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">erase</span>(iter[key]);</span><br><span class="line">        <span class="comment">// freq自增1</span></span><br><span class="line">        ++m[key].second;</span><br><span class="line">        <span class="comment">// 加入freq+1 list 表尾</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="comment">// 更新迭代器位置</span></span><br><span class="line">        iter[key] = --freq[m[key].second].<span class="built_in">end</span>();</span><br><span class="line">        <span class="comment">// 如果minFreq list 为空，则minFreq++</span></span><br><span class="line">        <span class="keyword">if</span>(freq[minFreq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            ++minFreq;</span><br><span class="line">        <span class="comment">// 返回key对应的value</span></span><br><span class="line">        <span class="keyword">return</span> m[key].first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该key之前已经存在，更新value即可</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            m[key] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            iter.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            freq[minFreq].<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m[key] = &#123;value, <span class="number">1</span>&#125;;</span><br><span class="line">        freq[<span class="number">1</span>].<span class="built_in">push_back</span>(key);</span><br><span class="line">        iter[key] = --freq[<span class="number">1</span>].<span class="built_in">end</span>();</span><br><span class="line">        minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 容量，最小频率</span></span><br><span class="line">    <span class="keyword">int</span> cap, minFreq;</span><br><span class="line">    <span class="comment">// key--&gt;(value, freq)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line">    <span class="comment">// freq--&gt;list：频率为freq对应的key存在一个list里</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt; &gt; freq;</span><br><span class="line">    <span class="comment">// key--&gt;list&lt;int&gt;::iterator，保存key在对应freq list里的迭代器，为了实现查找O(1)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;::iterator&gt; iter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LRU</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS\BFS算法</title>
    <url>/posts/51190.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十五章】</strong>豫兮其若冬涉川，犹兮其若畏四邻，俨兮其若容，涣兮若冰之将释，敦兮其若朴，旷兮其若谷，混兮其若浊。孰能浊以静之徐清？孰能安以久动之徐生？</p>
</blockquote>
<span id="more"></span>

<h2 id="431-找无向图的连通块"><a href="#431-找无向图的连通块" class="headerlink" title="431. 找无向图的连通块"></a><a href="https://www.lintcode.com/problem/431/">431. 找无向图的连通块</a></h2><blockquote>
<p>找出无向图中所有的连通块。<br>图中的每个节点包含一个label属性和一个邻接点的列表。（一个无向图的连通块是一个子图，其中任意两个顶点通过路径相连，且不与整个图中的其它顶点相连。）<br>你需要返回 label 集合的列表.</p>
</blockquote>
<h3 id="1、DFS解法"><a href="#1、DFS解法" class="headerlink" title="1、DFS解法"></a>1、DFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">count</span>(node-&gt;neighbors[i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;neighbors[i], cur);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、BFS解法"><a href="#2、BFS解法" class="headerlink" title="2、BFS解法"></a>2、BFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="comment">// dfs(nodes[i], cur);</span></span><br><span class="line">            <span class="built_in">bfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    queue&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    q.<span class="built_in">push</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        UndirectedGraphNode* tnode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : tnode-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis.<span class="built_in">count</span>(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            cur.<span class="built_in">push_back</span>(neighbor-&gt;label);</span><br><span class="line">            vis.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h3><blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效</strong>的括号组合。<br>示例 1：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;()&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 8<br>实现代码（DFS）：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, n, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; res, string&amp; cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(right &lt; left) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, left<span class="number">-1</span>, right);</span><br><span class="line">    cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, left, right<span class="number">-1</span>);</span><br><span class="line">    cur.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>DFS-BFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/46268.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十六章】</strong>致虚极，守静笃（dǔ），万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，是谓复命。复命曰常，知常曰明，不知常，妄作，凶。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>本文总结一下并查集在实际问题中的应用，体会一下并查集的精巧的构思^.^。<br><a href="https://labuladong.gitee.io/algo/2/20/40/">并查集的教程——来自labuladong</a></p>
</blockquote>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mp[num] = <span class="number">1</span>; cnt[num] = <span class="number">1</span>; fa[num] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[num+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">merge</span>(num+<span class="number">1</span>, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt[rootX];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[rootX] &gt; cnt[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            cnt[rootX] += cnt[rootY];</span><br><span class="line">            _cnt = cnt[rootX];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            cnt[rootY] += cnt[rootX];</span><br><span class="line">            _cnt = cnt[rootY]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp, cnt, fa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2><blockquote>
<p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n*m; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">merge</span>(i*m, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[i][m<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i*m+m<span class="number">-1</span>, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[n<span class="number">-1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>((n<span class="number">-1</span>)*m+i, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                            <span class="built_in">merge</span>(x*m+y, i*m+j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">connected</span>(i*m+j, dummy)) </span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootX==rootY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<h3 id="传统DFS解法"><a href="#传统DFS解法" class="headerlink" title="传统DFS解法"></a>传统DFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    grid[x][y] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(x+<span class="number">1</span>&lt;n &amp;&amp; grid[x+<span class="number">1</span>][y]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x+<span class="number">1</span>, y);</span><br><span class="line">    <span class="keyword">if</span>(x<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[x<span class="number">-1</span>][y]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x<span class="number">-1</span>, y);</span><br><span class="line">    <span class="keyword">if</span>(y+<span class="number">1</span>&lt;m &amp;&amp; grid[x][y+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(y<span class="number">-1</span>&gt;=<span class="number">0</span> &amp;&amp; grid[x][y<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, x, y<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                ans += <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集解法"><a href="#并查集解法" class="headerlink" title="并查集解法"></a>并查集解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx  =i*m + j;</span><br><span class="line">                fa[idx] = idx;</span><br><span class="line">                sz[idx] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = i*m + j;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i*m)+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树</title>
    <url>/posts/8911.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十七章】</strong>太上，不知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言。功成事遂，百姓皆谓我自然。</p>
</blockquote>
<span id="more"></span>

<h2 id="前缀树（Trie）介绍"><a href="#前缀树（Trie）介绍" class="headerlink" title="前缀树（Trie）介绍"></a>前缀树（Trie）介绍</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><blockquote>
<p>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) &#123;</span><br><span class="line">            a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            cur = cur-&gt;child[id]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="648-单词替换"><a href="#648-单词替换" class="headerlink" title="648. 单词替换"></a><a href="https://leetcode-cn.com/problems/replace-words/">648. 单词替换</a></h2><blockquote>
<p>给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        TrieNode *root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : dictionary) </span><br><span class="line">            <span class="built_in">insert</span>(root, word);</span><br><span class="line">        </span><br><span class="line">        <span class="function">istringstream <span class="title">in</span><span class="params">(sentence)</span></span>;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.<span class="built_in">empty</span>()) res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            res += <span class="built_in">findPrefix</span>(root, t);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">findPrefix</span><span class="params">(TrieNode* node, string&amp; word)</span> </span>&#123;</span><br><span class="line">        string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">push_back</span>(c);</span><br><span class="line">            node = node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;isWord) <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="676-实现一个魔法字典"><a href="#676-实现一个魔法字典" class="headerlink" title="676. 实现一个魔法字典"></a><a href="https://leetcode-cn.com/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></h2><blockquote>
<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。<br>如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root;</span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root, dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, searchWord, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TrieNode* root, string&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> edit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;isWord==<span class="literal">true</span> &amp;&amp; i==word.<span class="built_in">size</span>() &amp;&amp; edit==<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;word.<span class="built_in">size</span>() &amp;&amp; edit&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span> &amp;&amp; !found; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newEdit = (word[i]-<span class="string">&#x27;a&#x27;</span> == j) ? edit : edit+<span class="number">1</span>;</span><br><span class="line">                found = <span class="built_in">dfs</span>(root-&gt;child[j], word, i+<span class="number">1</span>, newEdit);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>前缀树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/posts/41510.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十八章】</strong>大道废，有仁义；智慧出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<strong>狄克斯特拉</strong>于1959年提出的，因此又叫狄克斯特拉算法。是从<strong>一个顶点到其余各顶点的最短路径算法</strong>，解决的是有权图中最短路径问题。<br>迪杰斯特拉算法主要特点是<strong>从起始点</strong>开始，采用<strong>贪心算法</strong>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。  ——来源：<a href="https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989">百度百科</a></p>
</blockquote>
<h2 id="PAT甲级·1003-Emergency-25-分"><a href="#PAT甲级·1003-Emergency-25-分" class="headerlink" title="PAT甲级·1003 Emergency (25 分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">PAT甲级·1003 Emergency (25 分)</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2- the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios_base::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> e[<span class="number">510</span>][<span class="number">510</span>], teamcnt[<span class="number">510</span>], dist[<span class="number">510</span>], w[<span class="number">510</span>], num[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(e[<span class="number">0</span>], e[<span class="number">0</span>] + <span class="number">510</span>*<span class="number">510</span>, inf);</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + <span class="number">510</span>, inf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, c1, c2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        cin &gt;&gt; teamcnt[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[a][b] = e[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dist[c1] = <span class="number">0</span>;</span><br><span class="line">    w[c1] = teamcnt[c1];</span><br><span class="line">    num[c1] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minn = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; minn) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minn = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[u] + e[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + e[u][v];</span><br><span class="line">                    w[v] = w[u] + teamcnt[v];</span><br><span class="line">                    num[v] = num[u];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dist[u] + e[u][v] == dist[v]) &#123;</span><br><span class="line">                    num[v] = num[v] + num[u];</span><br><span class="line">                    <span class="keyword">if</span>(w[u] + teamcnt[v] &gt; w[v]) </span><br><span class="line">                        w[v] = w[u] + teamcnt[v];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; num[c2] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; w[c2] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>dijkstra</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/posts/16074.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十九章】</strong>绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。此三者以为文不足，故令有所属；见素抱朴，少私寡欲；绝学无忧。</p>
</blockquote>
<span id="more"></span>

<h2 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h2><blockquote>
<p>请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指针i，j从索引0开始移动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//模式串匹配完毕，s也匹配完毕：匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i==n;</span><br><span class="line">        <span class="comment">// s:a, p:ab*c*</span></span><br><span class="line">        <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">            <span class="comment">//如果能匹配成功，一定是字母和*成对出现</span></span><br><span class="line">            <span class="keyword">if</span>((m-j)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//检查是否为x*y*z*的形式</span></span><br><span class="line">            <span class="keyword">for</span>(; j+<span class="number">1</span> &lt; m; j+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j+<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录状态（i，j）消除重叠子问题</span></span><br><span class="line">        string key = <span class="built_in">to_string</span>(i) + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key)) <span class="keyword">return</span> mp[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//匹配</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j] || p[j]==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//1-1 通配符匹配0次或多次</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                res =  <span class="built_in">helper</span>(s, i+<span class="number">1</span>, p, j) || </span><br><span class="line">                    <span class="built_in">helper</span>(s, i, p, j+<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1-2 常规匹配一次</span></span><br><span class="line">                res = <span class="built_in">helper</span>(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不匹配</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//2-1 通配符匹配0次</span></span><br><span class="line">                res =  <span class="built_in">helper</span>(s, i, p, j+<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//2-2 无法继续匹配</span></span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前结果记入备忘录</span></span><br><span class="line">        <span class="keyword">return</span> mp[key] = res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">bool</span>&gt; mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/35921.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十章】</strong> 众人皆有余，而我独若遗。我愚人之心也哉！俗人昭昭，我独昏昏。俗人察察，我独闷闷。</p>
</blockquote>
<span id="more"></span>

<p>KMP算法介绍，来自<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm"><strong>维基百科</strong></a></p>
<h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>传统的模式匹配算法中，当主串当前字符<strong>s[i]<strong>和模式串当前字符</strong>p[i]<strong>不匹配时，主串需要回溯至</strong>i=i-j+2</strong>位置，而模式串需回溯至<strong>j=1</strong>位置（下标从1开始）。引入next数组后，当主串和模式串不匹配时，只需将模式串回溯至**j=next[j]**位置，从而大大提高了匹配效率。假设我们有如下主串和模式串，该模式串next数组手动计算过程如下：<br><img src="/posts/35921/a.png"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(string&amp; p, vector&lt;<span class="keyword">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || p[i]==p[j])&#123;</span><br><span class="line">            ++i; ++j; next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string&amp; s, string p, vector&lt;<span class="keyword">int</span>&gt;&amp; next, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=s.<span class="built_in">size</span>() &amp;&amp; j&lt;=p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || s[i]==p[j]) &#123;</span><br><span class="line">            ++i; ++j;  <span class="comment">// 继续比较后续字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];  <span class="comment">// 模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j &gt; p.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> i-p.<span class="built_in">size</span>();  <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于next数组部分，跟着代码逻辑走一遍，具体过程如下：<br><img src="/posts/35921/c.png"></p>
<p><img src="/posts/35921/b.png"></p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>尽管普通模式匹配算法的时间复杂度为O(mn)，KMP算法的时间复杂度为O(m+n)，但在一般情况下，普通模式匹配的实际执行时间近似为O(m+n)，因此至今仍然被采用。KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快很多，其主要优点是<strong>主串不回溯</strong>。 </p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/posts/20721.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十一章】</strong> 孔德之容，惟道是从。道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈兮冥兮，其中有精，其精甚真，其中有信，自今及古，其名不去，以阅众甫。</p>
</blockquote>
<span id="more"></span>

<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; choice;</span><br><span class="line">string path;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(string&amp; s1, string&amp; s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    choice.<span class="built_in">resize</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                choice[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dp[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                choice[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                choice[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; choice, string&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(choice[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i<span class="number">-1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;gbabcdef&quot;</span>, s2 = <span class="string">&quot;gaczef&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">lcs</span>(s1, s2, m, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length of lcs: %d\n&quot;</span>, x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">findPath</span>(choice, s1, m, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lsc: &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述解法需要一个m*n的choice矩阵保存状态，实际上可进一步优化，不使用choice而是根据dp[i][j]、dp[i-1][j-1]、dp[i-1][j]以及dp[i-1][j-1]之间的大小关系直接进行路径逆推，下面是更优解法：</p>
<h2 id="findPath更优解法"><a href="#findPath更优解法" class="headerlink" title="findPath更优解法"></a>findPath更优解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n, string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m, j = n;</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(dp[m][n], <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = ans.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m][n - <span class="number">1</span>]) &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m - <span class="number">1</span>][n]) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[index--] = a[m - <span class="number">1</span>];</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>TopK</title>
    <url>/posts/41946.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十二章】</strong>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式。不自见，故明；不自是，故彰，不自伐，故有功；不自矜，故长。</p>
</blockquote>
<span id="more"></span>

<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><blockquote>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
</blockquote>
<h3 id="快速排序解法"><a href="#快速排序解法" class="headerlink" title="快速排序解法"></a>快速排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || input.<span class="built_in">size</span>()&lt;k) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = input.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(input, l, r);</span><br><span class="line">        <span class="keyword">if</span>(p+<span class="number">1</span> == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p+<span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序解法"><a href="#堆排序解法" class="headerlink" title="堆排序解法"></a>堆排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> n = input.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || n&lt;k) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 默认为最大堆，维护最小的k个数    </span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(input[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">push</span>(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找第K大"><a href="#寻找第K大" class="headerlink" title="寻找第K大"></a>寻找第K大</h2><blockquote>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。</p>
</blockquote>
<h3 id="快速排序解法-1"><a href="#快速排序解法-1" class="headerlink" title="快速排序解法"></a>快速排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机数选枢轴</span></span><br><span class="line">    <span class="keyword">int</span> randIdx = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[randIdx]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; K) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">        <span class="keyword">if</span>(p == K<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; K<span class="number">-1</span>) &#123;</span><br><span class="line">            l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序解法-1"><a href="#堆排序解法-1" class="headerlink" title="堆排序解法"></a>堆排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; K) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &lt; K) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>topk</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基本计算器</title>
    <url>/posts/44719.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十三章】</strong>从事于道者同于道；德者同于德；失者同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐得之。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请写一个整数计算器，支持加减乘三种运算和括号。数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内。要求：空间复杂度： O(n)，时间复杂度 O(n)。</p>
</blockquote>
<p>示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;1+2&quot;</span></span><br><span class="line">返回值：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>示例2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;(2*(3-4))*5&quot;</span></span><br><span class="line">返回值：<span class="number">-10</span></span><br></pre></td></tr></table></figure>

<p>示例3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;3+2*3*4-1&quot;</span></span><br><span class="line">返回值：<span class="number">26</span></span><br></pre></td></tr></table></figure>

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) num = num*<span class="number">10</span> + (c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;(&#x27;</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;)&#x27;</span>) cnt--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">solve</span>(s.<span class="built_in">substr</span>(i+<span class="number">1</span>, j-i<span class="number">-1</span>));</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span> || c==<span class="string">&#x27;+&#x27;</span> || c==<span class="string">&#x27;-&#x27;</span> || c==<span class="string">&#x27;*&#x27;</span> || c==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(sign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: stk.<span class="built_in">push</span>( num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: stk.<span class="built_in">push</span>(-num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: stk.<span class="built_in">top</span>()*=num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: stk.<span class="built_in">top</span>()/=num; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sign = c;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans += stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>基本计算器</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
