<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<blockquote>
<p>学习使用Hexo+Next搭建博客网站，这是第一篇博客！<br>文章将有以下分类：工具、技术、笔记、思考、生活、阅读、音乐。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>-博客 -Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/10121.html</url>
    <content><![CDATA[<blockquote>
<p>Hexo博客搭建及主题美化，来自<a href="https://yuumiy.github.io/posts/2789.html">岛田悠米的博客。</a></p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>-博客 -Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/62992.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>作为计算机专业科班的学生，想必学习算法的时候肯定学过<strong>排序</strong>。找工作面试的时候面试官也经常让手撕快排、堆排序等，所以总结一下关于（内部）排序算法的知识点还是很有必要滴！<br>废话不多说我们开始吧~</p>
</blockquote>
<p><img data-src="/posts/62992/hello.jpg"></p>
<span id="more"></span>

<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由插入排序的的思想可以引申出三个重要的排序算法：<em>直接插入排序</em>、<em>折半插入排序</em>和<em>希尔排序</em>。下面依次进行介绍~</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];  <span class="comment">// nums[0]哨兵，不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; nums[<span class="number">0</span>] &lt; nums[j]; --j)</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 复制nums[0]到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：最好情况O(n)，最坏情况O(n<sup>2</sup>)<br><strong>空间复杂度</strong>: O(1)<br><strong>稳定性</strong>：由于每次插入元素时总是从后往前先比较再移动，所以不会出现相等元素相对位置发生变化的情况，即直接插入排序是一种稳定的排序方法</p>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; nums[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        nums[high+<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：折半插入排序仅减少了比较元素的次数，而元素的移动次数并未改变。因此时间复杂度仍为O(n<sup>2</sup>)<br><strong>空间复杂度</strong>: O(1)<br><strong>稳定性</strong>：稳定</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk+<span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-dk]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>]&lt;nums[j]; j -= dk)</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                nums[j+dk] = nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>：n在某个特定范围内时，希尔排序时间复杂度为O(n<sup>1.3</sup>)，最坏情况下复杂度为O(n<sup>2</sup>)<br><strong>空间复杂度</strong>: O(1)<br><strong>稳定性</strong>：不稳定</p>
<h1 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所谓交换，就是指根据序列中两个元素的比较结果来对换这两个记录在序列中的位置。交换排序的算法很多，本文主要介绍冒泡排序和快速排序。</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j<span class="number">-1</span>], nums[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;  <span class="comment">// 本趟没有发生交换，说明序列已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>: 最好情况下为O(n)，最坏情况下O(n<sup>2</sup>)<br><strong>空间复杂度</strong>: O(1)<br><strong>稳定性</strong>：稳定</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;快速排序是对冒泡排序的一种改进，其基本思想是基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[low];  <span class="comment">// 第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) --high;</span><br><span class="line">        nums[low] = nums[high];  <span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">        nums[high] = nums[low];  <span class="comment">// 将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(nums, lowm, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>: 最好情况下为O(nlogn)，最坏情况下O(n<sup>2</sup>)<br><strong>空间复杂度</strong>: O(logn)<br><strong>稳定性</strong>：不稳定</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;选择排序基本思想是：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个。选择排序中的堆排序是考察的重点。</p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(nums[i], nums[min])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>建立大根堆的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, i, len);  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆向下调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿k较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">            i++;                          <span class="comment">// 取k较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=nums[i]) <span class="keyword">break</span>;       <span class="comment">// 筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];            <span class="comment">// 将nums[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                        <span class="comment">// 修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>]                     <span class="comment">// 被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(nums, len);              <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>; i--) &#123;            </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span>]);           <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, <span class="number">1</span>, i<span class="number">-1</span>);         <span class="comment">// 整理，把剩下的i-1个元素整理成堆</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点执行向上调整操作。<br>下面是堆的向上调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="keyword">int</span> nums[], inr k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参数k为向上调整的节点，也为堆的元素个数</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        nums[k] = nums[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>时间复杂度</strong>: 建堆时间复杂度O(n)，每次调整时间复杂度O(h)，故在最好、最坏和平均情况下堆排序时间复杂度为O(nlogn)<br><strong>空间复杂度</strong>: O(1)<br><strong>稳定性</strong>：不稳定</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>递归形式的2路归并排序算法</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
