<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello Hexo</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经】</strong>道可道，非常道；名可名，非常名。无名，天地之始，有名，万物之母。故常无欲，以观其妙，常有欲，以观其徼。此两者，同出而异名，同谓之玄，玄之又玄，众妙之门。  </p>
</blockquote>
<span id="more"></span>

<p>学习使用Hexo+Next搭建博客网站，这是第一篇博客！<br>文章将有以下分类：工具、技术、笔记、思考、生活、阅读、音乐。</p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/10121.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三章】</strong>不尚贤，使民不争；不贵难得之货，使民不为盗；不见（xiàn）可欲，使民心不乱。是以圣人之治，虚其心，实其腹；弱其志，强其骨。 </p>
</blockquote>
<!-- ![](hello.jpg) -->

<span id="more"></span>

<p>Hexo博客搭建及主题美化，来自<a href="https://yuumiy.github.io/posts/2789.html">岛田悠米的博客。</a></p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找左右边界</title>
    <url>/posts/701.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第四章】</strong>道冲而用之或不盈，渊兮似万物之宗。挫其锐，解其纷，和其光，同其尘。 湛兮似或存，吾不知谁之子，象帝之先。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本的二分搜索"><a href="#基本的二分搜索" class="headerlink" title="基本的二分搜索"></a>基本的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid+<span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩右边界，锁定左边界</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 循环结束条件：left=right+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>() || nums[left]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩左侧边界，锁定右侧边界</span></span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right&lt;<span class="number">0</span> || nums[right]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找第一个不小于目标值的数（lower-bound）"><a href="#查找第一个不小于目标值的数（lower-bound）" class="headerlink" title="查找第一个不小于目标值的数（lower_bound）"></a>查找第一个不小于目标值的数（lower_bound）</h2><p>比如在数组 [2, 4, 5, 6, 9] 中查找数字3，就会返回数字4的位置；在数组 [0, 1, 1, 1, 1] 中查找数字1，就会返回第一个数字1的位置。可变形为查找<strong>最后一个小于目标值</strong>的数（返回改为right-1）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查找第一个大于目标值的数（upper-bound"><a href="#查找第一个大于目标值的数（upper-bound" class="headerlink" title="查找第一个大于目标值的数（upper_bound)"></a>查找第一个大于目标值的数（upper_bound)</h2><p>比如在数组 [2, 4, 5, 6, 9] 中查找数字3，还是返回数字4的位置；在数组 [0, 1, 1, 1, 1] 中查找数字1，就会返回坐标5，通过<strong>对比返回的坐标和数组的长度</strong>，我们就知道是否存在这样一个大于目标值的数。可变形为查找<strong>最后一个不大于目标值</strong>的数（返改为回right-1）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/62992.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第五章】</strong>天地不仁，以万物为刍（chú）狗；圣人不仁，以百姓为刍狗。天地之间，其犹橐龠（tuó yuè）乎？虚而不屈，动而愈出。多言数（shuò）穷，不如守中。</p>
</blockquote>
<span id="more"></span>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。<br>由插入排序的的思想可以引申出三个重要的排序算法：<em>直接插入排序</em>、<em>折半插入排序</em>和<em>希尔排序</em>。下面依次进行介绍~</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];  <span class="comment">// nums[0]哨兵，不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; nums[<span class="number">0</span>] &lt; nums[j]; --j)</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 复制nums[0]到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：最好情况O(n)，最坏情况O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)； <strong>稳定性</strong>：由于每次插入元素时总是从后往前先比较再移动，所以不会出现相等元素相对位置发生变化的情况，即直接插入排序是一种稳定的排序方法</p>
</blockquote>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; nums[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        nums[high+<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：折半插入排序仅减少了比较元素的次数，而元素的移动次数并未改变，因此时间复杂度仍为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-dk]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>]&lt;nums[j]; j -= dk)</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                nums[j+dk] = nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：n在某个特定范围内时，希尔排序时间复杂度为O(n<sup>1.3</sup>)，最坏情况下复杂度为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>所谓交换，就是指根据序列中两个元素的比较结果来对换这两个记录在序列中的位置。交换排序的算法很多，本文主要介绍冒泡排序和快速排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j<span class="number">-1</span>], nums[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;  <span class="comment">// 本趟没有发生交换，说明序列已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(n)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的一种改进，其基本思想是基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[low];  <span class="comment">// 第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) --high;</span><br><span class="line">        nums[low] = nums[high];  <span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">        nums[high] = nums[low];  <span class="comment">// 将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// partitionII</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机数选枢轴</span></span><br><span class="line">    <span class="keyword">int</span> randIdx = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[randIdx]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(nums, low, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(nlogn)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: 最好情况下为(logn)，最坏情况下O(n)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序基本思想是：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个。选择排序中的堆排序是考察的重点。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(nums[i], nums[min])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建立大根堆的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, i, len);  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆向下调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿k较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">            i++;                          <span class="comment">// 取k较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=nums[i]) <span class="keyword">break</span>;       <span class="comment">// 筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];            <span class="comment">// 将nums[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                        <span class="comment">// 修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];                     <span class="comment">// 被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(nums, len);              <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; i--) &#123;            </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span>]);           <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, <span class="number">1</span>, i<span class="number">-1</span>);         <span class="comment">// 整理，把剩下的i-1个元素整理成堆</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点执行向上调整操作。<br>下面是堆的向上调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="keyword">int</span> nums[], inr k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参数k为向上调整的节点，也为堆的元素个数</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        nums[k] = nums[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 建堆时间复杂度O(n)，每次调整时间复杂度O(h)，故在最好、最坏和平均情况下堆排序时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归形式的2路归并排序算法是基于分治的其过程如下：<br>分解：将含有n个元素的待排序表分成含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。<br>合并：合并两个已经排序的子表得到排序结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;       </span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *_copy = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt;= high; k++) </span><br><span class="line">        _copy[k] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_copy[i] &lt;= _copy[j])</span><br><span class="line">            nums[k] = _copy[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = _copy[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) nums[k++] = _copy[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) nums[k++] = _copy[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 每趟归并时间复杂度为O(n)，共需logn趟归并，所以算法时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: 辅助空间占用n个单元，故空间复杂度为O(n)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华语流行乐教父罗大佑神级歌词</title>
    <url>/posts/47257.html</url>
    <content><![CDATA[<blockquote>
<p>音乐不是我一个人写的，那是所有人的“曾经”在心灵上的默契与融合，共同升华出一种年轻的感觉与驿动。每一双眼睛、每一张脸对我来讲都是不一样的，我是为了每一张不同的脸背后的故事而写歌。我希望能用音乐让整个世界、让人与人之间能够有一种心灵的交流。</p>
</blockquote>
<span id="more"></span>

<h2 id="恋曲1990"><a href="#恋曲1990" class="headerlink" title="恋曲1990"></a>恋曲1990</h2><blockquote>
<p>乌溜溜的黑眼珠<br>和你的笑脸<br>怎么也难忘记你<br>容颜的转变<br>轻飘飘的旧时光<br>就这么溜走<br>转头回去看看时<br>已匆匆数年<br>苍茫茫的天涯路<br>是你的飘泊<br>寻寻觅觅长相守<br>是我的脚步<br>黑漆漆的孤枕边<br>是你的温柔<br>醒来时的清晨里<br>是我的哀愁<br>或许明日太阳西下<br>倦鸟已归时<br>你将已经踏上<br>旧时的归途<br>人生难得再次寻觅<br>相知的伴侣<br>生命终究难舍<br>蓝蓝的白云天<br>轰隆隆的雷雨声<br>在我的窗前<br>怎么也难忘记你<br>离去的转变<br>孤单单的身影后<br>寂寥的心情<br>永远无怨的<br>是我的双眼</p>
</blockquote>
<h2 id="爱的箴言"><a href="#爱的箴言" class="headerlink" title="爱的箴言"></a>爱的箴言</h2><blockquote>
<p>我将真心付给了你<br>将悲伤留给我自己<br>我将青春付给了你<br>将岁月留给我自己<br>我将生命付给了你<br>将孤独留给我自己<br>我将春天付给了你<br>将冬天留给我自己<br><br>爱是没有人能了解的东西<br>爱是永恒的旋律<br>爱是欢笑泪珠飘落的过程<br>爱曾经是我也是你</p>
</blockquote>
<h2 id="光阴的故事"><a href="#光阴的故事" class="headerlink" title="光阴的故事"></a>光阴的故事</h2><blockquote>
<p>春天的花开秋天的风<br>以及冬天的落阳<br>忧郁的青春年少的我<br>曾经无知的这么想<br>风车在四季轮回的歌里<br>它天天地流转<br>风花雪月的诗句里<br>我在年年的成长<br>流水它带走光阴的故事<br>改变了一个人<br>就在那多愁善感而初次<br>等待的青春<br>发黄的相片古老的信<br>以及褪色的圣诞卡<br>年轻时为你写的歌<br>恐怕你早已忘了吧<br>过去的誓言就象那课本里<br>缤纷的书签<br>刻划着多少美丽的诗<br>可是终究是一阵烟<br>流水它带走光阴的故事<br>改变了两个人<br>就在那多愁善感而初次<br>流泪的青春<br>遥远的路程昨日的梦<br>以及远去的笑声<br>再次的见面我们又历经了<br>多少的路程<br>不再是旧日熟悉的我<br>有着旧日狂热的梦<br>也不是旧日熟悉的你<br>有着依然的笑容<br>流水它带走光阴的故事<br>改变了我们<br>就在那多愁善感而初次<br>回忆的青春</p>
</blockquote>
<h2 id="童年"><a href="#童年" class="headerlink" title="童年"></a>童年</h2><blockquote>
<p>池塘边的榕树上<br>知了在声声叫着夏天<br>操场边的秋千上<br>只有蝴蝶停在上面<br>黑板上老师的粉笔<br>还在拼命叽叽喳喳写个不停<br>等待着下课等待着放学<br>等待游戏的童年<br><br>福利社里面什么都有<br>就是口袋里没有半毛钱<br>诸葛四郎和魔鬼党<br>到底谁抢到那支宝剑<br>隔壁班的那个女孩<br>怎么还没经过我的窗前<br>嘴里的零食手里的漫画<br>心里初恋的童年<br><br>总是要等到睡觉前<br>才知道功课只做了一点点<br>总是要等到考试以后<br>才知道该念的书都没有念<br>一寸光阴一寸金<br>老师说过寸金难买寸光阴<br>一天又一天一年又一年<br>迷迷糊糊的童年<br><br>没有人知道为什么<br>太阳总下到山的那一边<br>没有人能够告诉我<br>山里面有没有住着神仙<br>多少的日子里总是<br>一个人面对着天空发呆<br>就这么好奇就这么幻想<br>这么孤单的童年<br><br>阳光下蜻蜓飞过来<br>一片片绿油油的稻田<br>水彩蜡笔和万花筒<br>画不出天边那一条彩虹<br>什么时候才能像高年级的同学<br>有张成熟与长大的脸<br>盼望着假期盼望着明天<br>盼望长大的童年<br><br>一天又一天一年又一年<br>盼望长大的童年 </p>
</blockquote>
<h2 id="东方之珠"><a href="#东方之珠" class="headerlink" title="东方之珠"></a>东方之珠</h2><blockquote>
<p>小河弯弯<br>向南流<br>流到香江<br>去看一看<br>东方之珠<br>我的爱人<br>你的风采<br>是否浪漫依然<br>月儿弯弯<br>的海港<br>夜色深深<br>灯火闪亮<br>东方之珠<br>整夜未眠<br>守着沧海桑田<br>变幻的诺言<br>让海风吹拂了五千年<br>每一滴泪珠<br>仿佛都说出<br>你的尊严<br>让海潮伴我来保佑你<br>请别忘记我<br>永远不变<br>黄色的脸<br><br>船儿弯弯<br>入海港<br>回头望望<br>沧海茫茫<br>东方之珠<br>拥抱着我<br>让我温暖<br>你那苍凉的胸膛</p>
</blockquote>
<h2 id="亚细亚的孤儿"><a href="#亚细亚的孤儿" class="headerlink" title="亚细亚的孤儿"></a>亚细亚的孤儿</h2><blockquote>
<p>亚细亚的孤儿<br>在风中哭泣<br>黄色的脸孔<br>有红色的污泥<br>黑色的眼珠<br>有白色的恐惧<br>西风在东方<br>唱着悲伤的歌曲<br>亚细亚的孤儿<br>在风中哭泣<br>没有人要和你<br>玩平等的游戏<br>每个人都想要<br>你心爱的玩具<br>亲爱的孩子<br>你为何哭泣<br><br>多少人在追寻<br>那解不开的问题<br>多少人在深夜里<br>无奈地叹息<br>多少人的眼泪<br>在无言中抹去<br>亲爱的母亲<br>这是什么道理<br>亲爱的母亲<br>这是什么真理</p>
</blockquote>
<h2 id="盲聋"><a href="#盲聋" class="headerlink" title="盲聋"></a>盲聋</h2><blockquote>
<p>我知道你听不到我的歌声<br>你也看不到这世界<br>也许你不了解有多少<br>愿意关怀你的人们<br>或许你早已适应了<br>黑暗的生存<br>或许你不愿接受<br>同情的滋润<br>来自庸俗的人<br><br>我知道他听得到我的歌声<br>他也看得清这世界<br>可是昨日的信仰<br>已变成了过去<br>狂热犹存的余温<br>人们欢聚在闹市里<br>喧嚣的霓虹灯<br>破落的庭院的主人<br>也成了回忆中<br>我们遗忘的人<br><br>有人因为失去了生命<br>而得到了不灭的永恒<br>有人为了生存而出卖了<br>他们可贵的灵魂<br>心中深处的天平上<br>你的欲望与真理在斗争<br>曾经一度自诩聪明的你<br>是个迷惑的人<br></p>
</blockquote>
<h2 id="现象七十二变"><a href="#现象七十二变" class="headerlink" title="现象七十二变"></a>现象七十二变</h2><blockquote>
<p>眼看着高楼盖得越来越高<br>我们的人情味却越来越薄<br>朋友之间越来越有礼貌<br>只因为大家见面越来越少<br>苹果价钱卖得没以前高<br>或许现在味道变得不好<br>就像彩色的电视变得更加花俏<br>能辨别黑白的人越来越少<br><br>是个什么样的心理因素<br>每年要吃掉一条高速公路<br>在西门町（台北）的天桥上面闲逛<br>有多少文明人在人行道上<br>就像我看到文明车辆横冲直撞<br>我不懂大家心中作何感想<br>一年过了又是新的一年<br>每一年现代都在传统边缘<br>在每个新的一年三百六十五天<br>我们都每天进步一点点</p>
</blockquote>
<h2 id="稻草人"><a href="#稻草人" class="headerlink" title="稻草人"></a>稻草人</h2><blockquote>
<p>终日面对着青山<br>终日面对着稻浪<br>午后的云雀背着艳阳<br>那样飞<br>那样笑<br>那样歌唱<br>轻风吹在我身上<br>雨珠打在我脸上<br>午后的牛羊凝向远方<br>彩虹画出的希望<br><br>蓝蓝的青空在上<br>却有着云雀与彩虹的梦<br>多像不知足的云四处飘荡<br>何处是我的归宿<br>是否在天际的那一端<br>奇怪着稻草的身躯如何飞翔<br><br>终日面对着青山<br>终日面对着稻浪<br>晨光<br>露珠<br>夕阳<br>星辰<br>春耕<br>秋收<br>冬藏</p>
</blockquote>
<h2 id="牧童"><a href="#牧童" class="headerlink" title="牧童"></a>牧童</h2><blockquote>
<p>牛背上的牧童<br>敞开你的胸扉<br>三月的苍茫<br>掩不住你树影下菊色的梦<br>风在林梢叹息<br>云在碧空飘逸<br>你冷漠的笛声<br>掠过青草带来泥土的芳香<br>九月的诗<br>早已埋藏在风雪之中<br>为何我听到<br>你胸口里热血汹涌<br>你看那<br>千古的泉水在山谷回旋<br>可知道<br>青鸟在树林呼唤你<br>牧童<br>田园已经荒芜<br>斜阳依然孤独<br>且让你的冷漠<br>投影在那泼墨残痕的归途</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>音乐</category>
        <category>罗大佑</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>哲学家的狂欢</title>
    <url>/posts/43432.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第七章】</strong>天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人后其身而身先，外其身而身存。非以其无私邪（yé）？故能成其私。</p>
</blockquote>
<span id="more"></span>

<h2 id="【哲学家的狂欢】上帝已死，哲学永生"><a href="#【哲学家的狂欢】上帝已死，哲学永生" class="headerlink" title="【哲学家的狂欢】上帝已死，哲学永生"></a>【哲学家的狂欢】上帝已死，哲学永生</h2><blockquote>
<p>上帝死了，但是人类会构筑一个千年不坏的山洞，在山洞里人们会展示他的形象。<br>——弗里德里希·威廉·尼采《快乐的知识》<br>（小字:上帝应当被杀死，并已经被杀死，他死于对人类的怜悯。怜悯是钉死爱人着的十字架。） <br><br>“别的小伙子都为了保卫文明穿上军装打仗去了，你就不惭愧么？”<br>“我就是他们要保卫的那种文明。”<br>——伯特兰·罗素（分析哲学的主要创始人）<br><br>“怀疑一切:我可以怀疑一切，但我却不能怀疑我正在怀疑。”<br>“我思故我在！”<br>——勒内·卡迪尔（法国哲学家）<br>（小字:永远只求克服自己，不求克服命运，只求改变自己的愿望，不求改变世间的秩序。）<br><br>如果不是我配不上这个时代，那就是这个时代配不上我。<br>——亚瑟·叔本华（德国著名哲学家）<br>（小字:一个人只有在独处时才能成为自己，因为一个人只有在独处时才是真正自由的。） <br><br>位我上者，灿烂星空，道德律令，在我心中。<br>——伊曼努尔·康德（古典哲学创始人）<br>（小字:我是孤独的，我是自由的，我是我自己的帝王。） <br><br>一个哲学家对自己的起码要求和最高要求是什么？<br>“在自己身上克服他的时代，成为无时代的人。”<br>——弗里德里希·威廉·尼采《瓦格纳事件》<br>（小字:世界弥漫着焦躁不安的气息，因为每一个人都急于从自己的枷锁中解放出来。） <br><br>离群索居者，不是野兽，便是神灵。<br>——亚里士多德《政治学》<br>（小字:野兽独居，因为他桀骜不驯。天神独居，因为他充实自足，然而，哲学家必须同时是两者。） <br><br>向死而生的意义是:当你无限接近死亡，才能深切体会生的意义。<br>——马丁·海德格尔（德国哲学家）<br>（小字:充满劳绩，然而人，诗意地栖居在大地之上。） <br><br>按照你所知道的最善的方式去生活。<br>——苏格拉底（古希腊哲学家）<br>（小字:在这个世界上，除了阳光，空气，水和笑容，我们还需要什么呢？） <br><br>若没有国家，没有政府，世界将是每一个人与每一个人的战争。<br>——托马斯·霍布斯（英国哲学家）<br>（小字:人在自然状态下总是处于自然状态，每个人对一切事物的自然权利会导致战争。） <br><br>当世界上最后一个爱国者死去的时候，和平就到来了。<br>——伯兰特·罗素（分析哲学的主要创始人） <br><br>那些许诺我们人间天堂的家伙，除了地狱什么也没搞出来。<br>——卡尔·波普尔（犹太商哲学家）<br>（小字:企图缔造人间天堂的结果无一例外造成人间地狱，它导致不宽容。） ​</p>
</blockquote>
<h2 id="爱情的哲学"><a href="#爱情的哲学" class="headerlink" title="爱情的哲学"></a>爱情的哲学</h2><blockquote>
<p>凭什么用“不结婚的男人”定义“单身汉”<br>——奎因<br><br>伟大的心灵总是雌雄同体的。<br>——柯勒律治<br><br>一个好女人能使她的男人变成快乐的人，一个坏女人会使她的男人变成哲学家。<br>——苏格拉底<br><br>只有哲学家能从婚姻中得到幸福，但哲学家是不结婚的。<br>——叔本华<br><br>智者永不入爱河。<br>——叔本华<br><br>爱情只有当它自由自在时才会叶茂花繁。以为爱情是某种义务的思想只能置爱情于死地，你应当爱某个人就足以使你对这个人恨之入骨。<br>——罗素<br><br>只折磨自己是单相思，只折磨他人是虐待狂，既折磨他人又折磨自己是爱情。<br>——黑格尔<br><br>我要单独而绝对的拥有你，不光要单独的爱，而且要单独的被爱，爱真是一种伟大的自私。<br>——尼采<br><br>爱情的实质不是互相爱慕，而是互相占有。<br>——叔本华<br><br>爱不是一种反应，如果我爱你是因为你爱我，那么这只是交易，爱变成了市场上被买卖的东西。<br>——克里希那穆提<br><br>如果放弃爱你，我的全部哲学将没有任何意义。<br>——雅斯贝尔斯<br><br>在我需要女人的时候，我无力供养她们；而当我有力供养她们时，我却已经不再需要女人了。<br>——康德<br><br>在我看来，真正的爱情表现在恋人对他的偶像采取含蓄、谦虚甚至羞涩的态度，而绝不是表现在随意流露热情和过早的亲昵。<br>——马克思<br><br>无论两条腿如何努力，也无法让两颗心的距离变得更近。<br>——梭罗<br><br>所谓爱，就是意识到我和另一个人的统一，爱的第一个环节，就是我不欲成为单独、孤单的个人；第二个环节，我在另一个人身上找到自己，即获得了他人对自己的承认，另一个人反过来也是如此。<br>——黑格尔<br></p>
</blockquote>
<h2 id="叔本华"><a href="#叔本华" class="headerlink" title="叔本华"></a>叔本华</h2><blockquote>
<p>我们读书时，是别人在代替我们思想，我们只不过重复他的思想活动的过程而已，犹如儿童启蒙习字时，用笔按照教师以铅笔所写的笔画依样画葫芦一般。我们的思想活动在读书时被免除了一大部分。因此，我们暂不自行思索而拿书来读时，会觉得很轻松，然而在读书时，我们的头脑实际上成为别人思想的运动场了。所以，读书愈多，或整天沉浸读书的人，虽然可借以休养精神，但他的思维能力必将渐次丧失，此犹如时常骑马的人步行能力必定较差，道理相同。<br><br>生命是一团欲望，欲望不能满足便痛苦，满足便无聊，人生就在痛苦和无聊之间摇摆。<br><br>一个人只有在独处时才能成为自己。谁要是不爱独处，那他就不爱自由，因为一个人只有在独处时才是真正自由的。<br><br>社交聚会要求人们做出牺牲，而一个人越具备独特的个性，那他就越难做出这样的牺牲。因此，一个人逃避、忍受抑或喜爱独处是和这一个人自身具备的价值恰成比例。因为在独处的时候，一个可怜虫就会感受到自己的全部可怜之处，而一个具有丰富思想的人只会感觉到自己丰富的思想。<br><br>学会在人群中保持一定程度上的孤独，不要有什么想法就立马告诉别人。另外，对别人所说的话千万不要太过当真。不能对别人有太多的期待，无论在道德上抑或在思想上。对于别人的看法，应锻炼出一副淡漠、无动于衷的态度，因为这是培养值得称道的宽容的一个最切实可行的手段。<br></p>
</blockquote>
<h2 id="《哲学九讲》节选"><a href="#《哲学九讲》节选" class="headerlink" title="《哲学九讲》节选"></a>《哲学九讲》节选</h2><blockquote>
<p>对于唯物主义，不管是哪种形式的唯物主义，一元论还是多元论，我们必须指出的是，物质性本体的观点到最后只能是精神上的自杀。如果构成整个宇宙的都是无意识的东西，那么我们称之为思想的东西以及思想活动，如果不能算是纯粹的物质，就只能是和热量、运动一样，作为其他物质实体的一种表现。思想与热量和运动将毫无差别，同样，我们也没有理由认为思想比温度或速度更重要。如果说思想只是某个物质实体一系列性质的表现，那它在物质上的意义就将等同于热量，而在精神上，则没有任何意义。而其所有成果，包括唯物主义本身在内，都将毫无意义，也毫无作用可言了。如果思想只是物质状态的产物，那么也就不会有什么至高无上的真理和唯物主义理论是否正确这样的问题了。所有的东西都只是像冰、水和水蒸气一样的存在，说唯物主义比唯心主义更正确，就好比说冰比水蒸气更真实一样没有意义，因为连真理这个词都是没有意义的。怀疑论者陷入了这么一个困境：如果他要否认所有观点和我们寻求真理的可能性，那他就必须同时否认支撑他去怀疑的观点，以及他意识到自己观点正确性的可能。而唯物主义者面临的困境也同样严峻。</p>
</blockquote>
<h2 id="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"><a href="#知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？" class="headerlink" title="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"></a>知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？</h2><blockquote>
<p>很多人意识不到，头顶的星空，才是生命最终极的意义所在，而我们的生活，不过是附属品而已。<br><br>低头看看你的手上的皮肤，上面的某一个原子，它来自你几天前吃下的一块牛肉，那头牛吃过一根草，这根草吸收了一片草原中的某些成分，这些成分是被一座远古火山喷出来的，那座火山喷出的都是地球内部的岩浆，这些岩浆在地球形成之前只是太阳系中的粉尘，这些粉尘来自一片星云，这片星云则来自太阳的前身星——一颗蓝巨星——垂死时产生的超新星爆发。而这颗蓝巨星诞生于更早的几亿年之前的第二代恒星死亡后的遗骸中，一直追朔到宇宙刚诞生的时候，所有这些东西都是一些夸克、胶子….你身体中所有大于铁的原子，都诞生于某颗超新星生命的最后时刻。<br><br>所以，说我们是星空的孩子，那是一点都不错的。可是你看看现在的人们，从他们的意识中，找得到一点和这有关的东西吗？找不到。人们只会关心当下的事，因为这和自己的切身利益直接相关，人们关心钱，关心亲人、爱人，关心工作，关心房价，关心友情，关心天气，将所有人类大脑与人类社会相互交杂后的必然产物掰开揉碎了分析得入木三分，然后按一种似乎是约定俗成的规则去做对自己最有利的事，将生活这一概念放大到无限大，占据了一个人内心的全部。<br><br>在这样一种大环境中，在某个晴朗无云的夜晚，在某个远离城市的静谧草原，你抬起头，一片明亮、壮丽、优雅、安详、神秘的广阔星空如一张巨幕赫然呈现在眼前，如一丝清雨将你世俗的双眼洗刷得干净透彻，什么都不剩，你与你最本质的归属之间再无任何隔阂，只有不断涌入眼中的无数星光直接打入你的内心。你怎能不感动？怎能不幸福？怎能不惊叹于世界之外这超越一切的最终极的美？这时你才意识到，你是社会的，但首先是自然的。<br><br>作者：<a href="https://www.zhihu.com/question/28006748/answer/39013684">萤火一号</a><br><br>来源：知乎</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>人文</category>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/posts/45955.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第八章】</strong>上善若水。水善利万物而不争，处众人之所恶（wù），故几（jī）于道。居善地，心善渊，与善仁，言善信，正善治，事善能，动善时。夫唯不争，故无尤。</p>
</blockquote>
<span id="more"></span>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p>
<h2 id="线索二叉树结构"><a href="#线索二叉树结构" class="headerlink" title="线索二叉树结构"></a>线索二叉树结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag; <span class="comment">// 左、右线索标志：0：孩子；1：前驱</span></span><br><span class="line">    <span class="built_in">ThreadNode</span>(<span class="keyword">int</span> x) : <span class="built_in">data</span>(x), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>), <span class="built_in">ltag</span>(<span class="number">0</span>), <span class="built_in">rtag</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ThreadNode* ThreadTree;</span><br></pre></td></tr></table></figure>

<h2 id="中序线索化二叉树"><a href="#中序线索化二叉树" class="headerlink" title="中序线索化二叉树"></a>中序线索化二叉树</h2><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;lchild, pre);  </span><br><span class="line">    <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;  </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;rchild, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树"><a href="#建立线索化二叉树" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点"><a href="#求第一个节点" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild; <span class="comment">// 最左下节点，不一定是叶节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点"><a href="#求后继节点" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// rtag=1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的中序线索二叉树的中序遍历"><a href="#不含头结点的中序线索二叉树的中序遍历" class="headerlink" title="不含头结点的中序线索二叉树的中序遍历"></a>不含头结点的中序线索二叉树的中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序线索化二叉树上实现前序遍历的算法"><a href="#中序线索化二叉树上实现前序遍历的算法" class="headerlink" title="中序线索化二叉树上实现前序遍历的算法"></a>中序线索化二叉树上实现前序遍历的算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);  <span class="comment">// 先访问根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;ltag == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 有左子树，即为后继</span></span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;rtag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有柚子树，即为后继</span></span><br><span class="line">            node = node-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无左右子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;rtag==<span class="number">1</span>) <span class="comment">// 检测后继线索 直到找到有右子树的结点</span></span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node =node-&gt;rchild;  <span class="comment">//该结点的右子树为后继</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口</title>
    <url>/posts/39893.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第九章】</strong>持而盈之，不如其已。揣(chuǎi)而锐之，不可长保。金玉满堂，莫之能守。富贵而骄，自遗（yí）其咎。功成身退，天之道。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法模板框架"><a href="#算法模板框架" class="headerlink" title="算法模板框架"></a>算法模板框架</h2><blockquote>
<p>滑动窗口算法的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。这里总结一套滑动窗口算法的通用模板：<br><br>来源：labuladong的算法小抄</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SlideWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/*********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode题目"><a href="#leetcode题目" class="headerlink" title="leetcode题目"></a>leetcode题目</h2><h3 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h3><blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数target。找出该数组中满足其和 ≥ target 的长度最小的连续子数组并返回其长度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>, ans = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        sum += nums[r];</span><br><span class="line">        r++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, r-l);</span><br><span class="line"></span><br><span class="line">            sum -= nums[l];</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans==INT_MAX ? <span class="number">0</span> : ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="713-乘积小于-K-的子数组"><a href="#713-乘积小于-K-的子数组" class="headerlink" title="713. 乘积小于 K 的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k/">713. 乘积小于 K 的子数组</a></h3><blockquote>
<p>给你一个数组nums和一个整数k，返回子数组内所有元素的乘积严格小于k的连续子数组的数目。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, p = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        p = p*nums[r];</span><br><span class="line">        r++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p &gt;= k) &#123;</span><br><span class="line">            p = p/nums[l];</span><br><span class="line">            l++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l == r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ans += (r&gt;l ? r-l : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">76.最小覆盖子串</a></h3><blockquote>
<p>给你一个字符串s、一个字符串t。返回s中涵盖t所有字符的最小子串。</p>
</blockquote>
<p>滑动窗口解法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>, start = <span class="number">0</span>, minlen = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(valid &gt;= need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; minlen) &#123;</span><br><span class="line">                minlen = right-left;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minlen==INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="159-至多包含两个不同字符的最长子串"><a href="#159-至多包含两个不同字符的最长子串" class="headerlink" title="159 至多包含两个不同字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/">159 至多包含两个不同字符的最长子串</a></h3><blockquote>
<p>给定一个字符串s，找出至多包含两个不同字符的最长子串t。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 滑动窗口</span></span><br><span class="line"><span class="comment">// 时间复杂度：O(n) 空间复杂度：O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;                <span class="comment">// 不同字符个数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;    <span class="comment">// right指向的是窗口外的下一个字符</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(window[s[r]] == <span class="number">0</span>)</span><br><span class="line">                cnt ++;             <span class="comment">// 出现新字符</span></span><br><span class="line">            </span><br><span class="line">            window[s[r]]++;        <span class="comment">// 计数+1并右移</span></span><br><span class="line">            r++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; <span class="number">2</span>)&#123;         <span class="comment">// 当窗口元素大于2，窗口缩小</span></span><br><span class="line">                window[s[l]]--;       <span class="comment">// 计数-1</span></span><br><span class="line">                l++;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(window[s[l]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cnt --;         <span class="comment">// 字符计数减为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            maxLen = <span class="built_in">max</span>(maxLen, r-l); <span class="comment">// 满足条件的窗口长度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3><blockquote>
<p>给你两个字符串s1和s2，写一个函数来判断s2是否包含s1的排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left &gt;= s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><blockquote>
<p>给定两个字符串s和p，找到s中所有p的异位词的子串，返回这些子串的起始索引。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        window[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(window.<span class="built_in">count</span>(d)) </span><br><span class="line">                window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, right-left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="395-至少有-K-个重复字符的最长子串"><a href="#395-至少有-K-个重复字符的最长子串" class="headerlink" title="395. 至少有 K 个重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有 K 个重复字符的最长子串</a></h3><blockquote>
<p>给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (k &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> kind = <span class="number">1</span>; kind &lt;= <span class="number">26</span>; kind++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(<span class="built_in">getRes</span>(s, k, kind), res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//kind 窗口内最大字符种类数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRes</span><span class="params">(string s, <span class="keyword">int</span> k, <span class="keyword">int</span> kind)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">cnt</span><span class="params">(<span class="number">26</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;  <span class="comment">// 当前窗口内字符种类数</span></span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;  <span class="comment">// 当前窗口内字符重复次数达到k的种类数</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">            <span class="keyword">int</span> indexR = s[right] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            cnt[indexR]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[indexR] == <span class="number">1</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt[indexR] == k) &#123;</span><br><span class="line">                total++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (sum &gt; kind) &#123;</span><br><span class="line">                <span class="keyword">int</span> indexL = s[left] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                cnt[indexL]--;</span><br><span class="line">                <span class="keyword">if</span> (cnt[indexL] == <span class="number">0</span>) &#123;</span><br><span class="line">                    sum--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt[indexL] == k<span class="number">-1</span>) &#123;</span><br><span class="line">                    total--;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum == total) &#123;</span><br><span class="line">                res = <span class="built_in">max</span>(res, right-left+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>滑动窗口算法的思路是这样：<br>1.我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。<br>2.我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>3.此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>4.重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>这个思路其实也不难，第 2 步相当于在寻找一个<strong>可行解</strong>，然后第 3 步在优化这个<strong>可行解</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微软CSS三面凉经</title>
    <url>/posts/39426.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十章】</strong>爱民治国，能无知（zhì）乎？天门开阖（hé），能无雌乎？明白四达，能无为乎？生之、畜（xù）之，生而不有，为而不恃，长（zhǎng）而不宰，是谓玄德。</p>
</blockquote>
<span id="more"></span>

<h2 id="一面（220307上午）"><a href="#一面（220307上午）" class="headerlink" title="一面（220307上午）"></a>一面（220307上午）</h2><h3 id="英文自我介绍"><a href="#英文自我介绍" class="headerlink" title="英文自我介绍"></a>英文自我介绍</h3><p>教育背景，专业技能，为什么来微软，为什么选CSS<br>本来准备了英语介绍，结果没背熟，，，硬着头皮说完了，看面试官表情当时感觉就无了</p>
<h3 id="专业问题"><a href="#专业问题" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li>OSI七层模型是什么，每层分别介绍一下</li>
<li>Http和Https区别</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>静态成员、非静态成员区别，在内存哪个区</li>
<li>指针变量占多少空间</li>
<li>说说析构函数</li>
<li>C++动态内存分配方法</li>
<li>头文件作用</li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>进程、线程区别</li>
<li>线程调度的时机</li>
</ul>
<h2 id="二面（220307下午）"><a href="#二面（220307下午）" class="headerlink" title="二面（220307下午）"></a>二面（220307下午）</h2><h3 id="中文自我介绍"><a href="#中文自我介绍" class="headerlink" title="中文自我介绍"></a>中文自我介绍</h3><p>对CSS了解吗，为什么选CSS</p>
<h3 id="专业问题-1"><a href="#专业问题-1" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h4><ul>
<li>Http和Https区别</li>
<li>Https如何work</li>
</ul>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul>
<li>介绍下用户空间、内核空间，用户态如何切内核态</li>
<li>static关键字</li>
</ul>
<h4 id="Role-Play"><a href="#Role-Play" class="headerlink" title="Role Play"></a>Role Play</h4><p><strong>英文场景题</strong>面试官是客户（老外），将网站部署在Microsoft云平台上，突然宕机了。全程英文来交流~ 然后就是大型翻车现场。。。</p>
<h2 id="三面（220309上午）"><a href="#三面（220309上午）" class="headerlink" title="三面（220309上午）"></a>三面（220309上午）</h2><ul>
<li>自我介绍</li>
<li>对CSS的理解，如何了解客户需求，帮助客户解决问题</li>
<li>自我职业规划</li>
<li>对云计算的理解（面试官是Azure部门的）</li>
<li>英文场景题，客户web server 宕机，要求今天解决，你如何回复（英文）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次微软面试经历，值得吸取的教训还是很多的</p>
<ul>
<li>首先因为第一次面试，可能略有紧张。自我介绍都翻车了。。。</li>
<li>八股文问的不深，但是细节还是没掌握。比如表示层会话层之前只是走马观花看了一下，结果现场想不起来了，和面试官大眼瞪小眼</li>
<li>认识到自己还有很多不足（英文口语、表达能力、应变能力等），以后要谨言慎行、谦虚谨慎、戒骄戒躁了~</li>
</ul>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>面经</category>
        <category>Microsoft</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode链表</title>
    <url>/posts/6854.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十二章】</strong>五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋（tián）猎令人心发狂，难得之货令人行妨。是以圣人为腹不为目，故去彼取此。</p>
</blockquote>
<span id="more"></span>

<h2 id="链表结构定义"><a href="#链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *fast = head, *slow = dummy;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *t = slow-&gt;next;</span><br><span class="line">    slow-&gt;next= slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>本题有两种解决思路，一种递归一种迭代，思路都很精巧，下面来一一介绍：</p>
</blockquote>
<h3 id="1、递归解法"><a href="#1、递归解法" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表为空；head指向尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、迭代解法"><a href="#2、迭代解法" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        LisNode *nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><blockquote>
<p>反转从位置left到位置right的链表节点。</p>
</blockquote>
<h3 id="1、递归解法-1"><a href="#1、递归解法-1" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        successor = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseN</span>(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、迭代解法（推荐）"><a href="#2、迭代解法（推荐）" class="headerlink" title="2、迭代解法（推荐）"></a>2、迭代解法（推荐）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode *pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= left<span class="number">-1</span>; i++) </span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *cur = pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *a = head, *b = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">revList</span>(a, b);</span><br><span class="line">    a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">revList</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = a;</span><br><span class="line">    <span class="keyword">while</span>(cur != b) &#123;</span><br><span class="line">        ListNode *nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。 </p>
</blockquote>
<h3 id="1、递归解法-2"><a href="#1、递归解法-2" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">traverse</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">traverse</span>(right-&gt;next);</span><br><span class="line">    res = res &amp;&amp; (left-&gt;val == right-&gt;val);</span><br><span class="line">    left = left-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代解法-1"><a href="#2、迭代解法-1" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在2；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *right = slow-&gt;next, *left = head;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    right = <span class="built_in">revList</span>(right);</span><br><span class="line">    <span class="keyword">while</span>(right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        left = left-&gt;next;</span><br><span class="line">        right = right-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">revList</span><span class="params">(ListNode* l)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = l;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(list1) cur-&gt;next = list1;</span><br><span class="line">    <span class="keyword">if</span>(list2) cur-&gt;next = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h2><blockquote>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在3；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。 如果两个链表不存在相交节点，返回 null 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *pa = headA, *pb = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">length</span>(headA);</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="built_in">length</span>(headB);</span><br><span class="line">    <span class="keyword">if</span>(la &gt; lb) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = la - lb;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pa = pa-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = lb - la;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa == pb) <span class="keyword">return</span> pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode* list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    ListNode* cur = list;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2><blockquote>
<p>给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    l1 = <span class="built_in">revList</span>(l1);</span><br><span class="line">    l2 = <span class="built_in">revList</span>(l2);</span><br><span class="line">    </span><br><span class="line">    ListNode *t = <span class="built_in">add</span>(l1, l2);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">revList</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">revList</span><span class="params">(ListNode* l)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = l;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">add</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1 || l2 || carry) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">        carry = sum/<span class="number">10</span>;</span><br><span class="line">        sum = sum%<span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum);</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur-&gt;next = t;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next) pq.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/classic/problems/sort-list/description/">148. 排序链表</a></h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow = head, *fast = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* half1 = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode* half2 = <span class="built_in">sortList</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(half1, half2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-II-029-排序的循环链表"><a href="#剑指-Offer-II-029-排序的循环链表" class="headerlink" title="剑指 Offer II 029. 排序的循环链表"></a><a href="https://leetcode-cn.com/problems/4ueAj6/">剑指 Offer II 029. 排序的循环链表</a></h2><blockquote>
<p>给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insert</span><span class="params">(Node* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Node *node = <span class="keyword">new</span> <span class="built_in">Node</span>(val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head = node;</span><br><span class="line">        head-&gt;next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(head-&gt;next == head) &#123;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">        node-&gt;next = head;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">helper</span>(head, node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node* head, Node* node)</span> </span>&#123;</span><br><span class="line">    Node *cur = head, *next = head-&gt;next;</span><br><span class="line">    Node *biggest = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!(cur-&gt;val&lt;=node-&gt;val &amp;&amp; next-&gt;val&gt;=node-&gt;val) &amp;&amp; next!=head) &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val &gt;= biggest-&gt;val) &#123;</span><br><span class="line">            biggest = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cur-&gt;val&lt;=node-&gt;val &amp;&amp; next-&gt;val&gt;=node-&gt;val) &#123;</span><br><span class="line">        cur-&gt;next = node;</span><br><span class="line">        node-&gt;next= next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node-&gt;next = biggest-&gt;next;</span><br><span class="line">        biggest-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/classic/problems/odd-even-linked-list/description/">328. 奇偶链表</a></h2><blockquote>
<p>定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *evenHead = head-&gt;next;</span><br><span class="line">    ListNode *odd = head, *even = evenHead;</span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h2><blockquote>
<p>L0 → L1 → … → Ln - 1 → Ln 请将其重新排列后变为：L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *last = slow-&gt;next, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(last != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *t = last-&gt;next;</span><br><span class="line">        last-&gt;next = pre;</span><br><span class="line">        pre = last;</span><br><span class="line">        last = t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *left = head, *right = pre;</span><br><span class="line">    <span class="keyword">while</span>(left &amp;&amp; right) &#123;</span><br><span class="line">        ListNode *lnext = left-&gt;next;</span><br><span class="line">        ListNode *rnext = right-&gt;next;</span><br><span class="line">        </span><br><span class="line">        left-&gt;next = right;</span><br><span class="line">        right-&gt;next = lnext;</span><br><span class="line">        left = lnext;</span><br><span class="line">        right = rnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><blockquote>
<p>给定一个已排序的链表的头 head，删除所有重复的元素，使每个元素只出现一次。</p>
</blockquote>
<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">    <span class="keyword">return</span> (head-&gt;val == head-&gt;next-&gt;val) ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur-&gt;val == cur-&gt;next-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="82-删除排序链表中的重复元素-II"><a href="#82-删除排序链表中的重复元素-II" class="headerlink" title="82. 删除排序链表中的重复元素 II"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><blockquote>
<p>给定一个已排序的链表的头head，删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head || !head-&gt;next) </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">        </span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *pre = dummy;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next) &#123;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val==cur-&gt;val) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur != pre-&gt;next) pre-&gt;next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">else</span> pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
        <category>leetcode题目</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS算法</title>
    <url>/posts/51190.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十五章】</strong>豫兮其若冬涉川，犹兮其若畏四邻，俨兮其若容，涣兮若冰之将释，敦兮其若朴，旷兮其若谷，混兮其若浊。孰能浊以静之徐清？孰能安以久动之徐生？</p>
</blockquote>
<span id="more"></span>
<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r - <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">        <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">if</span>(r + <span class="number">1</span> &lt; m &amp;&amp; grid[r + <span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    <span class="keyword">if</span>(c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(c + <span class="number">1</span> &lt; n &amp;&amp; grid[r][c + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="463-岛屿周长"><a href="#463-岛屿周长" class="headerlink" title="463. 岛屿周长"></a><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿周长</a></h2><blockquote>
<p>计算岛屿的周长。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid.<span class="built_in">size</span>()==<span class="number">0</span> || grid[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) </span><br><span class="line">                ans = <span class="built_in">dfs</span>(grid, n, m, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; grid, <span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=n || j&lt;<span class="number">0</span> || j&gt;=m)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(grid, n, m, i+<span class="number">1</span>, j) + <span class="built_in">dfs</span>(grid, n, m, i, j+<span class="number">1</span>) +</span><br><span class="line">        <span class="built_in">dfs</span>(grid, n, m, i<span class="number">-1</span>, j) + <span class="built_in">dfs</span>(grid, n, m, i, j<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h2><blockquote>
<p> 计算并返回 grid 中最大的岛屿面积。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = grid.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// if(h == 0) return 0;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> w = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; ++j) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">area</span>(grid, j, i, w, h));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">area</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt;= w || y &gt;= h || grid[y][x] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    grid[y][x] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">area</span>(grid, x<span class="number">-1</span>, y, w, h) + <span class="built_in">area</span>(grid, x+<span class="number">1</span>, y, w, h) + <span class="built_in">area</span>(grid, x, y<span class="number">-1</span>, w, h)</span><br><span class="line">        + <span class="built_in">area</span>(grid, x, y+<span class="number">1</span>, w, h) + <span class="number">1</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785. 判断二分图"></a><a href="https://leetcode.cn/problems/is-graph-bipartite/">785. 判断二分图</a></h2><blockquote>
<p>如果图是二分图，返回 true ；否则，返回 false 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">colors</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(colors[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(graph, colors, i, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; colors, <span class="keyword">int</span> i, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(colors[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> colors[i]==color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    colors[i] = color;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">dfs</span>(graph, colors, neighbor, <span class="number">1</span>-color)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="431-找无向图的连通块"><a href="#431-找无向图的连通块" class="headerlink" title="431. 找无向图的连通块"></a><a href="https://www.lintcode.com/problem/431/">431. 找无向图的连通块</a></h2><blockquote>
<p>找出无向图中所有的连通块。</p>
</blockquote>
<h3 id="1、DFS解法"><a href="#1、DFS解法" class="headerlink" title="1、DFS解法"></a>1、DFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">count</span>(node-&gt;neighbors[i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;neighbors[i], cur);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、BFS解法"><a href="#2、BFS解法" class="headerlink" title="2、BFS解法"></a>2、BFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="comment">// dfs(nodes[i], cur);</span></span><br><span class="line">            <span class="built_in">bfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    queue&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    q.<span class="built_in">push</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        UndirectedGraphNode* tnode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : tnode-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis.<span class="built_in">count</span>(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            cur.<span class="built_in">push_back</span>(neighbor-&gt;label);</span><br><span class="line">            vis.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode-cn.com/problems/generate-parentheses/">22. 括号生成</a></h2><blockquote>
<p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效</strong>的括号组合。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">3</span></span><br><span class="line">输出：[<span class="string">&quot;((()))&quot;</span>,<span class="string">&quot;(()())&quot;</span>,<span class="string">&quot;(())()&quot;</span>,<span class="string">&quot;()(())&quot;</span>,<span class="string">&quot;()()()&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：n = <span class="number">1</span></span><br><span class="line">输出：[<span class="string">&quot;()&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>1 &lt;= n &lt;= 8</li>
</ul>
<p>实现代码（DFS）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, n, n);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; res, string&amp; cur, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;<span class="number">0</span> || right&lt;<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(right &lt; left) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(left==<span class="number">0</span> &amp;&amp; right==<span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, left<span class="number">-1</span>, right);</span><br><span class="line">    cur.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(res, cur, left, right<span class="number">-1</span>);</span><br><span class="line">    cur.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h2><blockquote>
<p>给定一个mxn整数矩阵matrix ，找出其中最长递增路径的长度。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">9</span>,<span class="number">9</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：最长递增路径为 [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>]。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>]]</span><br><span class="line">输出：<span class="number">4</span> </span><br><span class="line">解释：最长递增路径是 [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; matrix, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; dp, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) <span class="keyword">return</span> dp[i][j];</span><br><span class="line"></span><br><span class="line">    dp[i][j]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nexti = i+dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextj = j+dirs[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span> &amp;&amp; nexti&lt;n &amp;&amp; nextj&gt;=<span class="number">0</span> &amp;&amp; nextj&lt;m &amp;&amp; matrix[i][j]&lt;matrix[nexti][nextj]) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">dfs</span>(matrix, dp, nexti, nextj)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>()==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(matrix, dp, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="不同路径的数目-一"><a href="#不同路径的数目-一" class="headerlink" title="不同路径的数目(一)"></a>不同路径的数目(一)</h2><blockquote>
<p>一个机器人在m×n大小的地图的左上角（起点）。机器人每次可以向下或向右移动。机器人要到达地图的右下角（终点）。可以有多少种不同的路径从起点走到终点？</p>
</blockquote>
<p>示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">2</span>,<span class="number">1</span></span><br><span class="line">返回值：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>示例2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="number">2</span>,<span class="number">2</span></span><br><span class="line">返回值：<span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dfs-备忘录"><a href="#dfs-备忘录" class="headerlink" title="dfs+备忘录"></a>dfs+备忘录</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; memo, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==m<span class="number">-1</span> || y==n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(memo[x][y]) <span class="keyword">return</span> memo[x][y];</span><br><span class="line">    memo[x][y] = <span class="built_in">dfs</span>(m, n, memo, x+<span class="number">1</span>, y) + <span class="built_in">dfs</span>(m, n, memo, x, y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[x][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">memo</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(m, n, memo, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/46268.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十六章】</strong>致虚极，守静笃（dǔ），万物并作，吾以观复。夫物芸芸，各复归其根。归根曰静，是谓复命。复命曰常，知常曰明，不知常，妄作，凶。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>本文总结一下并查集在实际问题中的应用，体会一下并查集的精巧的构思^.^。<br><a href="https://labuladong.gitee.io/algo/2/20/40/">并查集的教程——来自labuladong</a></p>
</blockquote>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列的长度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mp[num] = <span class="number">1</span>; cnt[num] = <span class="number">1</span>; fa[num] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[num+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">merge</span>(num+<span class="number">1</span>, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt[rootX];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[rootX] &gt; cnt[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            cnt[rootX] += cnt[rootY];</span><br><span class="line">            _cnt = cnt[rootX];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            cnt[rootY] += cnt[rootX];</span><br><span class="line">            _cnt = cnt[rootY]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp, cnt, fa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2><blockquote>
<p>找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n*m; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将第一列和最后一列O与dummy合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">merge</span>(i*m, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[i][m<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i*m+m<span class="number">-1</span>, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将第一行和最后一行O与dummy合并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[n<span class="number">-1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>((n<span class="number">-1</span>)*m+i, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                            <span class="built_in">merge</span>(x*m+y, i*m+j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">connected</span>(i*m+j, dummy)) </span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootX==rootY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>你计算网格中岛屿的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx  =i*m + j;</span><br><span class="line">                fa[idx] = idx;</span><br><span class="line">                sz[idx] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = i*m + j;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i*m)+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547. 省份数量"></a><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></h2><blockquote>
<p>给你一个 n x n 的矩阵 isConnected ，返回矩阵中 省份 的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = isConnected.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            cnt[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(isConnected[i][j] &amp;&amp; <span class="built_in">merge</span>(i, j)) &#123;</span><br><span class="line">                    ans--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x= fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cnt[rootX] &gt; cnt[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            cnt[rootX] += cnt[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            cnt[rootY] += cnt[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树</title>
    <url>/posts/8911.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十七章】</strong>太上，不知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言。功成事遂，百姓皆谓我自然。</p>
</blockquote>
<span id="more"></span>

<h2 id="前缀树（Trie）"><a href="#前缀树（Trie）" class="headerlink" title="前缀树（Trie）"></a>前缀树（Trie）</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><blockquote>
<p>请你实现 Trie 类。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) &#123;</span><br><span class="line">            a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            cur = cur-&gt;child[id]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="648-单词替换"><a href="#648-单词替换" class="headerlink" title="648. 单词替换"></a><a href="https://leetcode-cn.com/problems/replace-words/">648. 单词替换</a></h2><blockquote>
<p>给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        TrieNode *root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : dictionary) </span><br><span class="line">            <span class="built_in">insert</span>(root, word);</span><br><span class="line">        </span><br><span class="line">        <span class="function">istringstream <span class="title">in</span><span class="params">(sentence)</span></span>;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.<span class="built_in">empty</span>()) res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            res += <span class="built_in">findPrefix</span>(root, t);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">findPrefix</span><span class="params">(TrieNode* node, string&amp; word)</span> </span>&#123;</span><br><span class="line">        string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">push_back</span>(c);</span><br><span class="line">            node = node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;isWord) <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="676-实现一个魔法字典"><a href="#676-实现一个魔法字典" class="headerlink" title="676. 实现一个魔法字典"></a><a href="https://leetcode-cn.com/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></h2><blockquote>
<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。<br>如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root;</span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root, dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, searchWord, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TrieNode* root, string&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> edit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;isWord==<span class="literal">true</span> &amp;&amp; i==word.<span class="built_in">size</span>() &amp;&amp; edit==<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;word.<span class="built_in">size</span>() &amp;&amp; edit&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span> &amp;&amp; !found; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newEdit = (word[i]-<span class="string">&#x27;a&#x27;</span> == j) ? edit : edit+<span class="number">1</span>;</span><br><span class="line">                found = <span class="built_in">dfs</span>(root-&gt;child[j], word, i+<span class="number">1</span>, newEdit);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="820-单词的压缩编码"><a href="#820-单词的压缩编码" class="headerlink" title="820. 单词的压缩编码"></a><a href="https://leetcode.cn/problems/short-encoding-of-words/">820. 单词的压缩编码</a></h2><blockquote>
<p>给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                child[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TrieNode* node, <span class="keyword">int</span>&amp; ans, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> isLeaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[i]) &#123;</span><br><span class="line">                isLeaf = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(node-&gt;child[i], ans, dep+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(isLeaf) ans += dep;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumLengthEncoding</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(string&amp; s : words) &#123;</span><br><span class="line">            TrieNode *node = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = s[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!node-&gt;child[id]) node-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                node = node-&gt;child[id];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root, ans, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="677-键值映射"><a href="#677-键值映射" class="headerlink" title="677. 键值映射"></a><a href="https://leetcode.cn/problems/map-sum-pairs/">677. 键值映射</a></h2><blockquote>
<p>设计一个 map ，满足以下几点: 字符串表示键，整数表示值；返回具有前缀等于给定字符串的键的值的总和</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapSum</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                child[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MapSum</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur =  root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = key[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;val = val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getSum</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(TrieNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = node-&gt;val;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            ans += <span class="built_in">getSum</span>(node-&gt;child[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="421-数组中两个数的最大异或值"><a href="#421-数组中两个数的最大异或值" class="headerlink" title="421. 数组中两个数的最大异或值"></a><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></h2><blockquote>
<p>给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">        TrieNode *child[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">TrieNode</span>() &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                child[i] = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            TrieNode *node = root;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> bit = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(!node-&gt;child[bit]) node-&gt;child[bit] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">                node = node-&gt;child[bit];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            TrieNode *node = root;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">int</span> bit = (num&gt;&gt;i)&amp;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;child[<span class="number">1</span>-bit]) &#123;</span><br><span class="line">                    t = (t&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                    node = node-&gt;child[<span class="number">1</span>-bit];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    t = t&lt;&lt;<span class="number">1</span>;</span><br><span class="line">                    node = node-&gt;child[bit];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ans = <span class="built_in">max</span>(ans, t);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>前缀树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Dijkstra</title>
    <url>/posts/41510.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十八章】</strong>大道废，有仁义；智慧出，有大伪；六亲不和，有孝慈；国家昏乱，有忠臣。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家<strong>狄克斯特拉</strong>于1959年提出的，因此又叫狄克斯特拉算法。是从<strong>一个顶点到其余各顶点的最短路径算法</strong>，解决的是有权图中最短路径问题。<br>迪杰斯特拉算法主要特点是<strong>从起始点</strong>开始，采用<strong>贪心算法</strong>的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。  ——来源：<a href="https://baike.baidu.com/item/%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/23665989">百度百科</a></p>
</blockquote>
<h2 id="PAT甲级·1003-Emergency-25-分"><a href="#PAT甲级·1003-Emergency-25-分" class="headerlink" title="PAT甲级·1003 Emergency (25 分)"></a><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805523835109376">PAT甲级·1003 Emergency (25 分)</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2- the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.</p>
<h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios_base::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(0);</span></span><br><span class="line">    <span class="keyword">int</span> e[<span class="number">510</span>][<span class="number">510</span>], teamcnt[<span class="number">510</span>], dist[<span class="number">510</span>], w[<span class="number">510</span>], num[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill</span>(e[<span class="number">0</span>], e[<span class="number">0</span>] + <span class="number">510</span>*<span class="number">510</span>, inf);</span><br><span class="line">    <span class="built_in">fill</span>(dist, dist + <span class="number">510</span>, inf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, c1, c2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        cin &gt;&gt; teamcnt[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        e[a][b] = e[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dist[c1] = <span class="number">0</span>;</span><br><span class="line">    w[c1] = teamcnt[c1];</span><br><span class="line">    num[c1] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = <span class="number">-1</span>, minn = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; dist[j] &lt; minn) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                minn = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        visited[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; n; ++v) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[v] &amp;&amp; e[u][v] != inf) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[u] + e[u][v] &lt; dist[v]) &#123;</span><br><span class="line">                    dist[v] = dist[u] + e[u][v];</span><br><span class="line">                    w[v] = w[u] + teamcnt[v];</span><br><span class="line">                    num[v] = num[u];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dist[u] + e[u][v] == dist[v]) &#123;</span><br><span class="line">                    num[v] = num[v] + num[u];</span><br><span class="line">                    <span class="keyword">if</span>(w[u] + teamcnt[v] &gt; w[v]) </span><br><span class="line">                        w[v] = w[u] + teamcnt[v];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; num[c2] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; w[c2] &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>dijkstra</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/posts/16074.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十九章】</strong>绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有。此三者以为文不足，故令有所属；见素抱朴，少私寡欲；绝学无忧。</p>
</blockquote>
<span id="more"></span>

<h2 id="剑指-Offer-19-正则表达式匹配"><a href="#剑指-Offer-19-正则表达式匹配" class="headerlink" title="剑指 Offer 19. 正则表达式匹配"></a><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h2><blockquote>
<p>请实现一个函数用来匹配包含’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（含0次）。<br>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指针i，j从索引0开始移动</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(string&amp; s, <span class="keyword">int</span> i, string&amp; p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//模式串匹配完毕，s也匹配完毕：匹配成功</span></span><br><span class="line">        <span class="keyword">if</span>(j == m) <span class="keyword">return</span> i==n;</span><br><span class="line">        <span class="comment">// s:a, p:ab*c*</span></span><br><span class="line">        <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">            <span class="comment">//如果能匹配成功，一定是字母和*成对出现</span></span><br><span class="line">            <span class="keyword">if</span>((m-j)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//检查是否为x*y*z*的形式</span></span><br><span class="line">            <span class="keyword">for</span>(; j+<span class="number">1</span> &lt; m; j+=<span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j+<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录状态（i，j）消除重叠子问题</span></span><br><span class="line">        string key = <span class="built_in">to_string</span>(i) + <span class="string">&quot;,&quot;</span> + <span class="built_in">to_string</span>(j);</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(key)) <span class="keyword">return</span> mp[key];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//匹配</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j] || p[j]==<span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//1-1 通配符匹配0次或多次</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                res =  <span class="built_in">helper</span>(s, i+<span class="number">1</span>, p, j) || </span><br><span class="line">                    <span class="built_in">helper</span>(s, i, p, j+<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1-2 常规匹配一次</span></span><br><span class="line">                res = <span class="built_in">helper</span>(s, i+<span class="number">1</span>, p, j+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不匹配</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; p[j+<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">//2-1 通配符匹配0次</span></span><br><span class="line">                res =  <span class="built_in">helper</span>(s, i, p, j+<span class="number">2</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//2-2 无法继续匹配</span></span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将当前结果记入备忘录</span></span><br><span class="line">        <span class="keyword">return</span> mp[key] = res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;string, <span class="keyword">bool</span>&gt; mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>KMP算法</title>
    <url>/posts/35921.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十章】</strong> 众人皆有余，而我独若遗。我愚人之心也哉！俗人昭昭，我独昏昏。俗人察察，我独闷闷。</p>
</blockquote>
<span id="more"></span>

<p>KMP算法介绍，来自<a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm"><strong>维基百科</strong></a></p>
<h2 id="next数组"><a href="#next数组" class="headerlink" title="next数组"></a>next数组</h2><p>传统的模式匹配算法中，当主串当前字符s[i]和模式串当前字符p[j]不匹配时，主串需要回溯至<strong>i=i-j+2</strong>位置，而模式串需回溯至<strong>j=1</strong>位置（下标从1开始）。引入next数组后，当主串和模式串不匹配时，只需将模式串回溯至next[j]位置，从而大大提高了匹配效率。假设我们有如下主串和模式串，关于next数组部分，跟着代码逻辑走一遍，具体过程如下：<br><img src="/posts/35921/c.png"></p>
<p><img src="/posts/35921/b.png"></p>
<h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(string&amp; p, vector&lt;<span class="keyword">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    next[<span class="number">1</span>] = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>(i &lt; p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || p[i]==p[j])&#123;</span><br><span class="line">            ++i; ++j; next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KMP</span><span class="params">(string&amp; s, string p, vector&lt;<span class="keyword">int</span>&gt;&amp; next, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=s.<span class="built_in">size</span>() &amp;&amp; j&lt;=p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || s[i]==p[j]) &#123;</span><br><span class="line">            ++i; ++j;  <span class="comment">// 继续比较后续字符</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];  <span class="comment">// 模式串向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j &gt; p.<span class="built_in">size</span>()) </span><br><span class="line">        <span class="keyword">return</span> i-p.<span class="built_in">size</span>();  <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>尽管普通模式匹配算法的时间复杂度为O(mn)，KMP算法的时间复杂度为O(m+n)，但在一般情况下，普通模式匹配的实际执行时间近似为O(m+n)，因此至今仍然被采用。KMP算法仅在主串与子串有很多“部分匹配”时才显得比普通算法快很多，其主要优点是<strong>主串不回溯</strong>。 </p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>KMP</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列\串</title>
    <url>/posts/20721.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十一章】</strong> 孔德之容，惟道是从。道之为物，惟恍惟惚。惚兮恍兮，其中有象；恍兮惚兮，其中有物。窈兮冥兮，其中有精，其精甚真，其中有信，自今及古，其名不去，以阅众甫。</p>
</blockquote>
<span id="more"></span>

<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; choice;</span><br><span class="line">string path;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(string&amp; s1, string&amp; s2, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    choice.<span class="built_in">resize</span>(m+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                choice[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt;= dp[i][j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                choice[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                choice[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; choice, string&amp; s, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(choice[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i<span class="number">-1</span>, j<span class="number">-1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(s[i<span class="number">-1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(choice[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i<span class="number">-1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">findPath</span>(choice, s, i, j<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s1 = <span class="string">&quot;gbabcdef&quot;</span>, s2 = <span class="string">&quot;gaczef&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> n = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">lcs</span>(s1, s2, m, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length of lcs: %d\n&quot;</span>, x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">findPath</span>(choice, s1, m, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lsc: &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上述解法需要一个m*n的choice矩阵保存状态，实际上可进一步优化，不使用choice而是根据dp[i][j]、dp[i-1][j-1]、dp[i-1][j]以及dp[i-1][j-1]之间的大小关系直接进行路径逆推，下面是更优解法：</p>
<h2 id="findPath更优解法"><a href="#findPath更优解法" class="headerlink" title="findPath更优解法"></a>findPath更优解法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dp, <span class="keyword">int</span> m, <span class="keyword">int</span> n, string&amp; a, string&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = m, j = n;</span><br><span class="line">    <span class="function">string <span class="title">ans</span><span class="params">(dp[m][n], <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = ans.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m][n - <span class="number">1</span>]) &#123;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(m &gt; <span class="number">0</span> &amp;&amp; dp[m][n] == dp[m - <span class="number">1</span>][n]) &#123;</span><br><span class="line">            m--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[index--] = a[m - <span class="number">1</span>];</span><br><span class="line">            m--;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a>BM66 最长公共子串</h2><blockquote>
<p>给定两个字符串str1和str2,输出两个字符串的最长公共子串。题目保证str1和str2的最长公共子串存在且唯一。 </p>
</blockquote>
<p>示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;1AB2345CD&quot;</span>,<span class="string">&quot;12345EF&quot;</span></span><br><span class="line">返回值：<span class="string">&quot;2345&quot;</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">LCS</span><span class="params">(string str1, string str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> n = str1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> m = str2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(n+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &gt; mx) &#123;</span><br><span class="line">                mx = dp[i][j];</span><br><span class="line">                pos = i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str1.<span class="built_in">substr</span>(pos-mx+<span class="number">1</span>, mx);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>topk问题</title>
    <url>/posts/41946.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十二章】</strong>曲则全，枉则直，洼则盈，敝则新，少则得，多则惑。是以圣人抱一为天下式。不自见，故明；不自是，故彰，不自伐，故有功；不自矜，故长。</p>
</blockquote>
<span id="more"></span>

<h2 id="最小的k个数"><a href="#最小的k个数" class="headerlink" title="最小的k个数"></a>最小的k个数</h2><blockquote>
<p>给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。</p>
</blockquote>
<h3 id="快速排序解法"><a href="#快速排序解法" class="headerlink" title="快速排序解法"></a>快速排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || input.<span class="built_in">size</span>()&lt;k) <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = input.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(input, l, r);</span><br><span class="line">        <span class="keyword">if</span>(p+<span class="number">1</span> == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="keyword">int</span>&gt;(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p+<span class="number">1</span> &lt; k) &#123;</span><br><span class="line">            l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序解法"><a href="#堆排序解法" class="headerlink" title="堆排序解法"></a>堆排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> n = input.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || n&lt;k) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// 默认为最大堆，维护最小的k个数    </span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>&gt; pq;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &lt; k) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(input[i]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">push</span>(input[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找第K大"><a href="#寻找第K大" class="headerlink" title="寻找第K大"></a>寻找第K大</h2><blockquote>
<p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。</p>
</blockquote>
<h3 id="快速排序解法-1"><a href="#快速排序解法-1" class="headerlink" title="快速排序解法"></a>快速排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 随机数选枢轴</span></span><br><span class="line">    <span class="keyword">int</span> randIdx = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[r], nums[randIdx]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> pivot = nums[r];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt; r; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &gt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; K) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(a, l, r);</span><br><span class="line">        <span class="keyword">if</span>(p == K<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(p &lt; K<span class="number">-1</span>) &#123;</span><br><span class="line">            l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = p<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序解法-1"><a href="#堆排序解法-1" class="headerlink" title="堆排序解法"></a>堆排序解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; K) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &lt; K) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; pq.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">                pq.<span class="built_in">push</span>(a[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>topk</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>基本计算器</title>
    <url>/posts/44719.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十三章】</strong>从事于道者同于道；德者同于德；失者同于失。同于道者，道亦乐得之；同于德者，德亦乐得之；同于失者，失亦乐得之。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a>基本计算器</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote>
<p>请写一个整数计算器，支持加减乘三种运算和括号。数据范围：0≤∣s∣≤100，保证计算结果始终在整型范围内。要求：空间复杂度： O(n)，时间复杂度 O(n)。</p>
</blockquote>
<p>示例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;1+2&quot;</span></span><br><span class="line">返回值：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>示例2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;(2*(3-4))*5&quot;</span></span><br><span class="line">返回值：<span class="number">-10</span></span><br></pre></td></tr></table></figure>

<p>示例3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;3+2*3*4-1&quot;</span></span><br><span class="line">返回值：<span class="number">26</span></span><br></pre></td></tr></table></figure>

<h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[i];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c&gt;=<span class="string">&#x27;0&#x27;</span> &amp;&amp; c&lt;=<span class="string">&#x27;9&#x27;</span>) num = num*<span class="number">10</span> + (c-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;(&#x27;</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span>(s[j] == <span class="string">&#x27;)&#x27;</span>) cnt--;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            num = <span class="built_in">solve</span>(s.<span class="built_in">substr</span>(i+<span class="number">1</span>, j-i<span class="number">-1</span>));</span><br><span class="line">            i = j<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i==n<span class="number">-1</span> || c==<span class="string">&#x27;+&#x27;</span> || c==<span class="string">&#x27;-&#x27;</span> || c==<span class="string">&#x27;*&#x27;</span> || c==<span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span>(sign) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: stk.<span class="built_in">push</span>( num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: stk.<span class="built_in">push</span>(-num); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: stk.<span class="built_in">top</span>()*=num; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: stk.<span class="built_in">top</span>()/=num; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sign = c;</span><br><span class="line">            num = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        ans += stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>基本计算器</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>链表减法</title>
    <url>/posts/27546.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十四章】</strong>企者不立，跨者不行；自见者不明；自是者不彰；自伐者无功；自矜者不长。其在道也，曰余食赘形。物或恶之，故有道者不处。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>Given two linked lists that represent two large positive numbers. Subtract the smaller number from the larger one and return the difference as a linked list. Note that the input lists may be in any order, but we always need to subtract smaller from the larger ones.<br>It may be assumed that there are no extra leading zeros in input lists.<br><a href="https://www.geeksforgeeks.org/subtract-two-numbers-represented-as-linked-lists/">文章转载自GeeksForGeeks</a></p>
</blockquote>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Input: l1 = <span class="number">1</span> -&gt; <span class="number">0</span> -&gt; <span class="number">0</span> -&gt; <span class="literal">NULL</span>,  l2 = <span class="number">1</span> -&gt; <span class="literal">NULL</span></span><br><span class="line">Output: <span class="number">0</span>-&gt;<span class="number">9</span>-&gt;<span class="number">9</span>-&gt;<span class="literal">NULL</span></span><br><span class="line">Explanation: Number represented as </span><br><span class="line">lists are <span class="number">100</span> <span class="keyword">and</span> <span class="number">1</span>, so <span class="number">100</span> - <span class="number">1</span> is <span class="number">099</span></span><br><span class="line"></span><br><span class="line">Input: l1 = <span class="number">7</span>-&gt; <span class="number">8</span> -&gt; <span class="number">6</span> -&gt; <span class="literal">NULL</span>,  l2 = <span class="number">7</span> -&gt; <span class="number">8</span> -&gt; <span class="number">9</span> <span class="literal">NULL</span></span><br><span class="line">Output: <span class="number">3</span>-&gt;<span class="literal">NULL</span></span><br><span class="line">Explanation: Number represented as </span><br><span class="line">lists are <span class="number">786</span> <span class="keyword">and</span>  <span class="number">789</span>, so <span class="number">789</span> - <span class="number">786</span> is <span class="number">3</span>, </span><br><span class="line">as the smaller value is subtracted from </span><br><span class="line">the larger one.</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<ol>
<li>Calculate sizes of given two linked lists.</li>
<li>If sizes are not the same, then append zeros in the smaller linked list.</li>
<li>If the size is the same, then follow the below steps:</li>
</ol>
<ul>
<li>Find the smaller valued linked list.</li>
<li>One by one subtract nodes of the smaller-sized linked list from the larger size. Keep track of borrow while subtracting.</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ program to subtract smaller valued list from</span></span><br><span class="line"><span class="comment">// larger valued list and return result as a list.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A linked List Node</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility which creates Node.</span></span><br><span class="line"><span class="function">Node* <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* temp = <span class="keyword">new</span> Node;</span><br><span class="line">	temp-&gt;data = data;</span><br><span class="line">	temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A utility function to get length</span></span><br><span class="line"><span class="comment">of linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(Node* Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (Node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		Node = Node-&gt;next;</span><br><span class="line">		size++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A Utility that padds zeros in front of the</span></span><br><span class="line"><span class="comment">Node, with the given diff */</span></span><br><span class="line"><span class="function">Node* <span class="title">paddZeros</span><span class="params">(Node* sNode, <span class="keyword">int</span> diff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (sNode == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Node* zHead = <span class="built_in">newNode</span>(<span class="number">0</span>);</span><br><span class="line">	diff--;</span><br><span class="line">	Node* temp = zHead;</span><br><span class="line">	<span class="keyword">while</span> (diff--) &#123;</span><br><span class="line">		temp-&gt;next = <span class="built_in">newNode</span>(<span class="number">0</span>);</span><br><span class="line">		temp = temp-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	temp-&gt;next = sNode;</span><br><span class="line">	<span class="keyword">return</span> zHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Subtract LinkedList Helper is a recursive function,</span></span><br><span class="line"><span class="comment">move till the last Node, and subtract the digits and</span></span><br><span class="line"><span class="comment">create the Node and return the Node. If d1 &lt; d2, we</span></span><br><span class="line"><span class="comment">borrow the number from previous digit. */</span></span><br><span class="line"><span class="function">Node* <span class="title">subtractLinkedListHelper</span><span class="params">(Node* l1, Node* l2, <span class="keyword">bool</span>&amp; borrow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l1 == <span class="literal">NULL</span> &amp;&amp; l2 == <span class="literal">NULL</span> &amp;&amp; borrow == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Node* previous</span><br><span class="line">		= <span class="built_in">subtractLinkedListHelper</span>(</span><br><span class="line">			l1 ? l1-&gt;next : <span class="literal">NULL</span>,</span><br><span class="line">			l2 ? l2-&gt;next : <span class="literal">NULL</span>, borrow);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> d1 = l1-&gt;data;</span><br><span class="line">	<span class="keyword">int</span> d2 = l2-&gt;data;</span><br><span class="line">	<span class="keyword">int</span> sub = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if you have given the value to next digit then</span></span><br><span class="line"><span class="comment">	reduce the d1 by 1 */</span></span><br><span class="line">	<span class="keyword">if</span> (borrow) &#123;</span><br><span class="line">		d1--;</span><br><span class="line">		borrow = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If d1 &lt; d2, then borrow the number from previous digit.</span></span><br><span class="line"><span class="comment">	Add 10 to d1 and set borrow = true; */</span></span><br><span class="line">	<span class="keyword">if</span> (d1 &lt; d2) &#123;</span><br><span class="line">		borrow = <span class="literal">true</span>;</span><br><span class="line">		d1 = d1 + <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* subtract the digits */</span></span><br><span class="line">	sub = d1 - d2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Create a Node with sub value */</span></span><br><span class="line">	Node* current = <span class="built_in">newNode</span>(sub);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set the Next pointer as Previous */</span></span><br><span class="line">	current-&gt;next = previous;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This API subtracts two linked lists and returns the</span></span><br><span class="line"><span class="comment">linked list which shall have the subtracted result. */</span></span><br><span class="line"><span class="function">Node* <span class="title">subtractLinkedList</span><span class="params">(Node* l1, Node* l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Base Case.</span></span><br><span class="line">	<span class="keyword">if</span> (l1 == <span class="literal">NULL</span> &amp;&amp; l2 == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// In either of the case, get the lengths of both</span></span><br><span class="line">	<span class="comment">// Linked list.</span></span><br><span class="line">	<span class="keyword">int</span> len1 = <span class="built_in">getLength</span>(l1);</span><br><span class="line">	<span class="keyword">int</span> len2 = <span class="built_in">getLength</span>(l2);</span><br><span class="line"></span><br><span class="line">	Node *lNode = <span class="literal">NULL</span>, *sNode = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	Node* temp1 = l1;</span><br><span class="line">	Node* temp2 = l2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If lengths differ, calculate the smaller Node</span></span><br><span class="line">	<span class="comment">// and padd zeros for smaller Node and ensure both</span></span><br><span class="line">	<span class="comment">// larger Node and smaller Node has equal length.</span></span><br><span class="line">	<span class="keyword">if</span> (len1 != len2) &#123;</span><br><span class="line">		lNode = len1 &gt; len2 ? l1 : l2;</span><br><span class="line">		sNode = len1 &gt; len2 ? l2 : l1;</span><br><span class="line">		sNode = <span class="built_in">paddZeros</span>(sNode, <span class="built_in">abs</span>(len1 - len2));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// If both list lengths are equal, then calculate</span></span><br><span class="line">		<span class="comment">// the larger and smaller list. If 5-6-7 &amp; 5-6-8</span></span><br><span class="line">		<span class="comment">// are linked list, then walk through linked list</span></span><br><span class="line">		<span class="comment">// at last Node as 7 &lt; 8, larger Node is 5-6-8</span></span><br><span class="line">		<span class="comment">// and smaller Node is 5-6-7.</span></span><br><span class="line">		<span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">			<span class="keyword">if</span> (l1-&gt;data != l2-&gt;data) &#123;</span><br><span class="line">				lNode = l1-&gt;data &gt; l2-&gt;data ? temp1 : temp2;</span><br><span class="line">				sNode = l1-&gt;data &gt; l2-&gt;data ? temp2 : temp1;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			l1 = l1-&gt;next;</span><br><span class="line">			l2 = l2-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If both lNode and sNode still have NULL value,</span></span><br><span class="line">	<span class="comment">// then this means that the value of both of the given linked lists</span></span><br><span class="line">	<span class="comment">// is the same and hence we can directly return a node with value 0.</span></span><br><span class="line">	<span class="keyword">if</span>(lNode==<span class="literal">NULL</span>&amp;&amp;sNode==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">newNode</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// After calculating larger and smaller Node, call</span></span><br><span class="line">	<span class="comment">// subtractLinkedListHelper which returns the subtracted</span></span><br><span class="line">	<span class="comment">// linked list.</span></span><br><span class="line">	<span class="keyword">bool</span> borrow = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">subtractLinkedListHelper</span>(lNode, sNode, borrow);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A utility function to print linked list */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(struct Node* Node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (Node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, Node-&gt;data);</span><br><span class="line">		Node = Node-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver program to test above functions</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Node* head1 = <span class="built_in">newNode</span>(<span class="number">1</span>);</span><br><span class="line">	head1-&gt;next = <span class="built_in">newNode</span>(<span class="number">0</span>);</span><br><span class="line">	head1-&gt;next-&gt;next = <span class="built_in">newNode</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	Node* head2 = <span class="built_in">newNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	Node* result = <span class="built_in">subtractLinkedList</span>(head1, head2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printList</span>(result);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
        <category>链表相减</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/posts/12682.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二章】</strong>天下皆知美之为美，斯恶（è）已；皆知善之为善，斯不善已。故有无相生，难易相成，长短相较，高下相倾，音声相和（hè），前后相随。</p>
</blockquote>
<span id="more"></span>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *p = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归遍历方法-1"><a href="#递归遍历方法-1" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;left);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-1"><a href="#非递归遍历方法-1" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode *p = stk.<span class="built_in">top</span>(); </span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归遍历方法-2"><a href="#递归遍历方法-2" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-2"><a href="#非递归遍历方法-2" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk1.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk1.<span class="built_in">top</span>();</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        stk2.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk2.<span class="built_in">top</span>();</span><br><span class="line">        stk2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="107-二叉树的层序遍历-II"><a href="#107-二叉树的层序遍历-II" class="headerlink" title="107. 二叉树的层序遍历 II"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></h2><blockquote>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    stack&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = q.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cnt--) &#123;</span><br><span class="line">            TreeNode* tmp = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            v1.<span class="built_in">push_back</span>(tmp-&gt;val);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;left) q.<span class="built_in">push</span>(tmp-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;right) q.<span class="built_in">push</span>(tmp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stk.<span class="built_in">push</span>(v1);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        v.<span class="built_in">emplace_back</span>(stk.<span class="built_in">top</span>());</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><blockquote>
<p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) &#123;</span><br><span class="line">            TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(i == sz) res.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="103-二叉树的锯齿形层序遍历"><a href="#103-二叉树的锯齿形层序遍历" class="headerlink" title="103. 二叉树的锯齿形层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h2><blockquote>
<p>给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
</blockquote>
<h3 id="解法一（栈）"><a href="#解法一（栈）" class="headerlink" title="解法一（栈）"></a>解法一（栈）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">Print</span>(TreeNode* pRoot) &#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span>) <span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt = <span class="number">1</span>;</span><br><span class="line">    stk[cur].<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">while</span>(!stk[<span class="number">0</span>].<span class="built_in">empty</span>() || !stk[<span class="number">1</span>].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *t = stk[cur].<span class="built_in">top</span>(); stk[cur].<span class="built_in">pop</span>();</span><br><span class="line">        out.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) stk[nxt].<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) stk[nxt].<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) stk[nxt].<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) stk[nxt].<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(stk[cur].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cur = <span class="number">1</span>-cur;</span><br><span class="line">            nxt = <span class="number">1</span>-nxt;</span><br><span class="line">            res.<span class="built_in">push_back</span>(out);</span><br><span class="line">            out.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="解法二（deque）"><a href="#解法二（deque）" class="headerlink" title="解法二（deque）"></a>解法二（deque）</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            deque&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">            <span class="keyword">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(step%<span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                    dq.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dq.<span class="built_in">push_front</span>(t-&gt;val);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.<span class="built_in">push_back</span>(vector&lt;<span class="keyword">int</span>&gt;&#123;dq.<span class="built_in">begin</span>(), dq.<span class="built_in">end</span>()&#125;);</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100. 相同的树"></a><a href="https://leetcode-cn.com/problems/same-tree/">100. 相同的树</a></h2><blockquote>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">nullptr</span> &amp;&amp; q==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (p-&gt;val==q-&gt;val) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; </span><br><span class="line">        <span class="built_in">isSameTree</span>(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h2><blockquote>
<p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!left &amp;&amp; !right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isSymmetric</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">isSymmetric</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><blockquote>
<p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">    TreeNode *right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    root-&gt;left = right;</span><br><span class="line">    root-&gt;right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> l = <span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> r = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l&gt;r ? l+<span class="number">1</span> : r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="110-平衡二叉树"><a href="#110-平衡二叉树" class="headerlink" title="110. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">110. 平衡二叉树</a></h2><blockquote>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">depth</span>(pRoot) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">int</span> ldep = <span class="built_in">depth</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span>(ldep == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> rdep = <span class="built_in">depth</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">if</span>(rdep == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> diff = <span class="built_in">abs</span>(ldep - rdep);</span><br><span class="line">    <span class="keyword">if</span>(diff &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ldep, rdep) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="958-二叉树的完全性检验"><a href="#958-二叉树的完全性检验" class="headerlink" title="958. 二叉树的完全性检验"></a><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h2><blockquote>
<p>给定一个二叉树的 root ，确定它是否是一个 完全二叉树 。在一个 完全二叉树 中，除了最后一个关卡外，所有关卡都是完全被填满的，并且最后一个关卡中的所有节点都是尽可能靠左的。它可以包含 1 到 2h 节点之间的最后一级 h 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(!t) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                TreeNode *t1 = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t1) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(t) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h2><blockquote>
<p>给你两棵二叉树： root1 和 root2 。想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="literal">nullptr</span> &amp;&amp; t2==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t1==<span class="literal">nullptr</span>) <span class="keyword">return</span> t2;</span><br><span class="line">    <span class="keyword">if</span>(t2==<span class="literal">nullptr</span>) <span class="keyword">return</span> t1;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t1-&gt;val + t2-&gt;val);</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = <span class="built_in">mergeTrees</span>(t1-&gt;left, t2-&gt;left);</span><br><span class="line">    root-&gt;right = <span class="built_in">mergeTrees</span>(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<!-- # 线索化二叉树 -->

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>顺时针打印矩阵</title>
    <url>/posts/54334.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十五章】</strong>大曰逝，逝曰远，远曰反。故道大，天大，地大，人亦大。域中有四大，而人居其一焉。人法地，地法天，天法道，道法自然。</p>
</blockquote>
<span id="more"></span>

<h2 id="剑指-Offer-29-顺时针打印矩阵"><a href="#剑指-Offer-29-顺时针打印矩阵" class="headerlink" title="剑指 Offer 29. 顺时针打印矩阵"></a><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a></h2><blockquote>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。</p>
</blockquote>
<p>示例1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>示例2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>],[<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<ul>
<li>0 &lt;= matrix.length &lt;= 100</li>
<li>0 &lt;= matrix[i].length &lt;= 100</li>
</ul>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// top为上界，bottom为下界，left为左界，right为右界</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>()<span class="number">-1</span>, left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>()*matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(k &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 向右</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = left; j&lt;=right &amp;&amp; k&lt;n; j++) &#123;</span><br><span class="line">            res[k] = matrix[top][j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上界下移一行</span></span><br><span class="line">        top++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向下</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = top; i&lt;=bottom &amp;&amp; k&lt;n; i++) &#123;</span><br><span class="line">            res[k] = matrix[i][right];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右界左移一列</span></span><br><span class="line">        right--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = right; j&gt;=left &amp;&amp; k&lt;n; j--) &#123;</span><br><span class="line">            res[k] = matrix[bottom][j];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下界上移一行</span></span><br><span class="line">        bottom--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom; i&gt;=top &amp;&amp; k&lt;n; i--) &#123;</span><br><span class="line">            res[k] = matrix[i][left];</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左界右移一列</span></span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>复原IP地址</title>
    <url>/posts/14404.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十六章】</strong> 重为轻根，静为躁君。是以君子终日行不离辎重，虽有荣观，燕处超然。奈何万乘之主，而以身轻天下？轻则失根，躁则失君。</p>
</blockquote>
<span id="more"></span>

<h2 id="93-复原-IP-地址"><a href="#93-复原-IP-地址" class="headerlink" title="93. 复原 IP 地址"></a><a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原 IP 地址</a></h2><blockquote>
<p>有效IP地址 正好由四个整数（0到255，不含前导 0），整数之间用 ‘.’ 分隔。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;25525511135&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;255.255.11.135&quot;</span>,<span class="string">&quot;255.255.111.35&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;0000&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;0.0.0.0&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;101023&quot;</span></span><br><span class="line">输出：[<span class="string">&quot;1.0.10.23&quot;</span>,<span class="string">&quot;1.0.102.3&quot;</span>,<span class="string">&quot;10.1.0.23&quot;</span>,<span class="string">&quot;10.10.2.3&quot;</span>,<span class="string">&quot;101.0.2.3&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>1 &lt;= s.length &lt;= 20</li>
<li>s仅由数字组成</li>
</ul>
<h3 id="回溯法一"><a href="#回溯法一" class="headerlink" title="回溯法一:"></a>回溯法一:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="built_in">helper</span>(s, res, <span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(string s, vector&lt;string&gt;&amp; res, string out, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; k) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, k));</span><br><span class="line">        <span class="keyword">if</span>(val&gt;<span class="number">255</span> || k!=std::<span class="built_in">to_string</span>(val).<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">helper</span>(s.<span class="built_in">substr</span>(k), res, out+s.<span class="built_in">substr</span>(<span class="number">0</span>, k)+(n==<span class="number">3</span> ? <span class="string">&quot;&quot;</span>:<span class="string">&quot;.&quot;</span>), n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回溯法二"><a href="#回溯法二" class="headerlink" title="回溯法二:"></a>回溯法二:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string&amp; s, vector&lt;string&gt;&amp; res, string&amp; cur, <span class="keyword">int</span> step, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index != s.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string t1 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i&lt;index+<span class="number">3</span> &amp;&amp; i&lt;s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        t1 += s[i];</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">stoi</span>(t1);</span><br><span class="line">        string t2 = cur;</span><br><span class="line">        <span class="keyword">if</span>(num&lt;=<span class="number">255</span> &amp;&amp; (t1.<span class="built_in">size</span>()==<span class="number">1</span> || t1[<span class="number">0</span>]!=<span class="string">&#x27;0&#x27;</span>)) &#123;</span><br><span class="line">            cur += t1;</span><br><span class="line">            <span class="keyword">if</span>(step != <span class="number">3</span>) cur += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, res, cur, step+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">            cur = t2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    <span class="built_in">dfs</span>(s, res, cur, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法:"></a>迭代法:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = <span class="number">1</span>; a &lt; <span class="number">4</span>; a++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> b = <span class="number">1</span>; b &lt; <span class="number">4</span>; b++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">4</span>; c++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">1</span>; d &lt; <span class="number">4</span>; d++) </span><br><span class="line">        <span class="keyword">if</span>(a+b+c+d == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> va = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, a));</span><br><span class="line">            <span class="keyword">int</span> vb = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a, b));</span><br><span class="line">            <span class="keyword">int</span> vc = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a+b, c));</span><br><span class="line">            <span class="keyword">int</span> vd = <span class="built_in">stoi</span>(s.<span class="built_in">substr</span>(a+b+c, d));</span><br><span class="line">            <span class="keyword">if</span>(va&lt;=<span class="number">255</span> &amp;&amp; vb&lt;=<span class="number">255</span> &amp;&amp; vc&lt;=<span class="number">255</span> &amp;&amp; vd&lt;=<span class="number">255</span>) &#123;</span><br><span class="line">                string t = <span class="built_in">to_string</span>(va) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(vb) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(vc) + <span class="string">&quot;.&quot;</span> + <span class="built_in">to_string</span>(vd);</span><br><span class="line">                <span class="keyword">if</span>(t.<span class="built_in">size</span>() == s.<span class="built_in">size</span>()+<span class="number">3</span>) res.<span class="built_in">push_back</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>BFS算法</title>
    <url>/posts/28489.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十七章】</strong> 善行，无辙迹；善言，无瑕谪；善数，不用筹策；善闭，无关楗而不可开；善结，无绳约而不可解。是以圣人常善救人，故无弃人；常善救物，故无弃物。</p>
</blockquote>
<span id="more"></span>

<h2 id="111-二叉树的最小深度"><a href="#111-二叉树的最小深度" class="headerlink" title="111. 二叉树的最小深度"></a><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h2><blockquote>
<p>给定一个二叉树，找出其最小深度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dep = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode *t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!t-&gt;left &amp;&amp; !t-&gt;right) <span class="keyword">return</span> dep;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dep++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="433-最小基因变化"><a href="#433-最小基因变化" class="headerlink" title="433. 最小基因变化"></a><a href="https://leetcode-cn.com/problems/minimum-genetic-mutation/">433. 最小基因变化</a></h2><blockquote>
<p>找出并返回能够使 start 变化为 end 所需的最少变化次数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">char</span>&gt; gens&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;T&#x27;</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMutation</span><span class="params">(string start, string end, vector&lt;string&gt;&amp; bank)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bank.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    unordered_set&lt;string&gt; s&#123;bank.<span class="built_in">begin</span>(), bank.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    unordered_set&lt;string&gt; visited;</span><br><span class="line">    queue&lt;string&gt; q&#123;&#123;start&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            string t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(t == end) <span class="keyword">return</span> level;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; t.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> old = t[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : gens) &#123;</span><br><span class="line">                    t[j] = c;</span><br><span class="line">                    <span class="keyword">if</span>(s.<span class="built_in">count</span>(t) &amp;&amp; !visited.<span class="built_in">count</span>(t)) &#123;</span><br><span class="line">                        visited.<span class="built_in">insert</span>(t);</span><br><span class="line">                        q.<span class="built_in">push</span>(t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                t[j] = old;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ++level;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="752-打开转盘锁"><a href="#752-打开转盘锁" class="headerlink" title="752. 打开转盘锁"></a><a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></h2><blockquote>
<p>给出解锁需要的最小旋转次数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">plusOne</span><span class="params">(string s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[j] == <span class="string">&#x27;9&#x27;</span>) </span><br><span class="line">        s[j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        s[j] += <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">minusOne</span><span class="params">(string s, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s[j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        s[j] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        s[j] -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">    unordered_set&lt;string&gt; dead, vis;</span><br><span class="line">    <span class="keyword">for</span>(string&amp; s : deadends) dead.<span class="built_in">insert</span>(s);</span><br><span class="line"></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    vis.<span class="built_in">insert</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.<span class="built_in">size</span>(); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            string t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dead.<span class="built_in">count</span>(t)) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(t == target) </span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                string up = <span class="built_in">plusOne</span>(t, j);</span><br><span class="line">                <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(up)) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(up);</span><br><span class="line">                    vis.<span class="built_in">insert</span>(up);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                string down = <span class="built_in">minusOne</span>(t, j);</span><br><span class="line">                <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(down)) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(down);</span><br><span class="line">                    vis.<span class="built_in">insert</span>(down);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1293-网格中的最短路径"><a href="#1293-网格中的最短路径" class="headerlink" title="1293. 网格中的最短路径"></a><a href="https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/">1293. 网格中的最短路径</a></h2><blockquote>
<p>找出从左上角到右下角的最短路径，并返回步数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; dirs&#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shortestPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">vis</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">    </span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = k;</span><br><span class="line">    queue&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, k&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = q.<span class="built_in">size</span>(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>]==m<span class="number">-1</span> &amp;&amp; t[<span class="number">1</span>]==n<span class="number">-1</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = t[<span class="number">0</span>]+dir[<span class="number">0</span>], y = t[<span class="number">1</span>]+dir[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;=m || y&lt;<span class="number">0</span> || y&gt;=n) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> newK = t[<span class="number">2</span>]-grid[x][y];</span><br><span class="line">                <span class="keyword">if</span>(newK&lt;<span class="number">0</span> || newK&lt;=vis[x][y]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                vis[x][y] = newK;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x, y, newK&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 扩散了一层，路径增加一</span></span><br><span class="line">        ++ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="675-为高尔夫比赛砍树"><a href="#675-为高尔夫比赛砍树" class="headerlink" title="675. 为高尔夫比赛砍树"></a><a href="https://leetcode.cn/problems/cut-off-trees-for-golf-event/">675. 为高尔夫比赛砍树</a></h2><blockquote>
<p>按照树的高度从低向高砍掉所有的树。</p>
</blockquote>
<p>示例 1：<br><img src="/posts/28489/trees1.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：沿着上面的路径，你可以用 <span class="number">6</span> 步，按从最矮到最高的顺序砍掉这些树。</span><br></pre></td></tr></table></figure>

<p>示例 2：<br><img src="/posts/28489/trees2.jpg"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：forest = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>]]</span><br><span class="line">输出：<span class="number">-1</span></span><br><span class="line">解释：由于中间一行被障碍阻塞，无法访问最下面一行中的树。</span><br></pre></td></tr></table></figure>

<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：forest = [[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>],[<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>]]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：可以按与示例 <span class="number">1</span> 相同的路径来砍掉所有的树。</span><br><span class="line">(<span class="number">0</span>,<span class="number">0</span>) 位置的树，可以直接砍去，不用算步数。</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<ul>
<li>m == forest.length</li>
<li>n == forest[i].length</li>
<li>1 &lt;= m, n &lt;= 50</li>
<li>0 &lt;= forest[i][j] &lt;= 109</li>
</ul>
<p>实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> w, x, y;</span><br><span class="line">        <span class="built_in">data</span>(<span class="keyword">int</span> w, <span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;w = w;</span><br><span class="line">            <span class="keyword">this</span>-&gt;x = x;</span><br><span class="line">            <span class="keyword">this</span>-&gt;y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">data</span>()&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> visited[<span class="number">55</span>][<span class="number">55</span>];</span><br><span class="line">    <span class="keyword">int</span> dir_x[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dir_y[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest, <span class="keyword">int</span> start_x, <span class="keyword">int</span> start_y, <span class="keyword">int</span> target_x, <span class="keyword">int</span> target_y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;start_x, start_y&#125;);</span><br><span class="line">        visited[start_x][start_y] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> q_size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q_size; i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = q.<span class="built_in">front</span>().first;</span><br><span class="line">                <span class="keyword">int</span> y = q.<span class="built_in">front</span>().second;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(x == target_x &amp;&amp; y == target_y) <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">int</span> xx = x + dir_x[j];</span><br><span class="line">                    <span class="keyword">int</span> yy = y + dir_y[j];</span><br><span class="line">                    <span class="keyword">if</span>(xx &gt;= <span class="number">0</span> &amp;&amp; yy &gt;= <span class="number">0</span> &amp;&amp; xx &lt; m &amp;&amp; yy &lt; n &amp;&amp; forest[xx][yy] &amp;&amp; !visited[xx][yy])&#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;xx, yy&#125;);</span><br><span class="line">                        visited[xx][yy] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">        m = forest.<span class="built_in">size</span>();</span><br><span class="line">        n = forest[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;data&gt; arr;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(forest[i][j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="comment">// 1是地面不是树</span></span><br><span class="line">                    arr.<span class="built_in">push_back</span>(&#123;forest[i][j], i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [&amp;](<span class="keyword">const</span> data &amp;a, <span class="keyword">const</span> data &amp;b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.w &lt; b.w;<span class="comment">//小到大</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">int</span> pre_x = <span class="number">0</span>, pre_y = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [w, x, y] : arr)&#123;</span><br><span class="line">            <span class="keyword">int</span> step = <span class="built_in">bfs</span>(forest, pre_x, pre_y, x, y);</span><br><span class="line">            <span class="comment">// cout &lt;&lt; step &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(step == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            ans += step;</span><br><span class="line">            <span class="built_in">memset</span>(visited, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visited));</span><br><span class="line">            pre_x = x, pre_y = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/posts/60354.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十八章】</strong>知其雄，守其雌，为天下溪。为天下溪，常德不离，复归于婴儿。知其白，守其黑，为天下式，为天下式，常德不忒，复归于无极。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>本文参考资料来自<a href="https://leetcode-cn.com/problems/last-stone-weight-ii/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-5lfv/">此处</a></p>
</blockquote>
<h2 id="背包问题的解题模板"><a href="#背包问题的解题模板" class="headerlink" title="背包问题的解题模板"></a>背包问题的解题模板</h2><p>二维版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt;&amp; wt, vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(N+<span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(W+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">1</span>; w &lt;= W; w++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(w - wt[i<span class="number">-1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 背包容量不够了，这种情况下只能选择不装入背包</span></span><br><span class="line">                dp[i][w] = dp[i<span class="number">-1</span>][w];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 装入或不装入背包，择优</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][w-wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]),</span><br><span class="line">                               dp[i<span class="number">-1</span>][w]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态压缩：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span> W, <span class="keyword">int</span> N, vector&lt;<span class="keyword">int</span>&gt;&amp; wt, vector&lt;<span class="keyword">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case 已初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(W+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = W; j &gt;= wt[i<span class="number">-1</span>]; j--) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j-wt[i<span class="number">-1</span>]]+val[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="背包问题分类"><a href="#背包问题分类" class="headerlink" title="背包问题分类"></a>背包问题分类</h2><p>常见的背包类型主要有以下几种：</p>
<ol>
<li>&nbsp;0/1背包问题：每个元素最多选取一次</li>
<li>完全背包问题：每个元素可以重复选择</li>
<li>组合背包问题：背包中的物品要考虑顺序</li>
<li>分组背包问题：不止一个背包，需要遍历每个背包</li>
</ol>
<p>而每个背包问题要求的也是不同的，按照所求问题分类，又可以分为以下几种：</p>
<ol>
<li>最值问题：要求最大值/最小值</li>
<li>存在问题：是否存在…………，满足…………</li>
<li>组合问题：求所有满足……的排列组合</li>
</ol>
<p>首先是背包分类的模板：</p>
<ol>
<li>&nbsp;0/1背包：外循环nums,内循环target,target倒序且target&gt;=nums[i];</li>
<li>完全背包：外循环nums,内循环target,target正序且target&gt;=nums[i];</li>
<li>组合背包：外循环target,内循环nums,target正序且target&gt;=nums[i];</li>
<li>分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</li>
</ol>
<p>然后是问题分类的模板：</p>
<ol>
<li>最值问题: dp[i] = max/min(dp[i], dp[i-nums]+1)或dp[i] = max/min(dp[i], dp[i-num]+nums);</li>
<li>存在问题(bool)：dp[i]=dp[i]||dp[i-num];</li>
<li>组合问题：dp[i]+=dp[i-num];</li>
</ol>
<h2 id="1049-最后一块石头的重量-II"><a href="#1049-最后一块石头的重量-II" class="headerlink" title="1049. 最后一块石头的重量 II"></a><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h2><blockquote>
<p>从一堆石头中,每次拿两块重量分别为x,y的石头,若x=y,则两块石头均粉碎;若x&lt;y,两块石头变为一块重量为y-x的石头求最后剩下石头的最小重量(若没有剩下返回0)</p>
</blockquote>
<p>0/1背包最值问题：外循环stones,内循环target=sum/2倒序,应用转移方程1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastStoneWeightII</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;stones)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(stones.<span class="built_in">begin</span>(), stones.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> stone : stones)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= stone; i--)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[i - stone] + stone);</span><br><span class="line">    <span class="keyword">return</span> (sum - dp[target]) - dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/">322. 零钱兑换</a></h2><blockquote>
<p>给定amount,求用任意数量不同面值的零钱换到amount所用的最少数量</p>
</blockquote>
<p>完全背包最值问题：外循环coins,内循环amount正序,应用状态方程1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//给dp数组每个位置赋初值为INT_MAX是为了最后判断是否能填满amount,要用long long 类型</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, INT_MAX)</span></span>; </span><br><span class="line">    <span class="comment">//dp[i]:换到面值i所用的最小数量</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coin &lt;= i)</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount]==INT_MAX ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><blockquote>
<p>分割等和子集：判断是否能将一个数组分割为两个子集,其和相等</p>
</blockquote>
<p>0-1背包存在性问题：是否存在一个子集,其和为target=sum/2,外循环nums,内循环target倒序,应用状态方程2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span> == <span class="number">1</span>)  <span class="comment">//如果是和为奇数显然无法分成两个等和子集</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> target = sum / <span class="number">2</span>; </span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">//dp[i]:是否存在子集和为i</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="literal">true</span>;   <span class="comment">//初始化：target=0不需要选择任何元素，所以是可以实现的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= num; i--)</span><br><span class="line">            dp[i] = dp[i] || dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494. 目标和"></a><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h2><blockquote>
<p>目标和：给数组里的每个数字添加正负号得到target</p>
</blockquote>
<p>数组和sum,目标和s, 正数和x,负数和y,则x+y=sum,x-y=s,那么x=(s+sum)/2=target<br>0-1背包不考虑元素顺序的组合问题:选nums里的数得到target的种数,外循环nums,内循环target倒序,应用状态方程3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((sum + s) % <span class="number">2</span> != <span class="number">0</span> || sum &lt; s)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> target = (sum + s) / <span class="number">2</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= num; i--)</span><br><span class="line">            dp[i] += dp[i - num];</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h2><blockquote>
<p>完全平方数：对于一个正整数n,找出若干个完全平方数使其和为n,返回完全平方数最少数量</p>
</blockquote>
<p>完全背包的最值问题：完全平方数最小为1,最大为sqrt(n),故题目转换为在nums=[1,2…..sqrt(n)]中选任意数平方和为target=n。外循环nums,内循环target正序,应用转移方程1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">//dp[i]:和为i的完全平方数的最小数量</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">1</span>; num &lt;= <span class="built_in">sqrt</span>(n); num++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= num * num)</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i], dp[i - num * num] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-组合总和-Ⅳ"><a href="#377-组合总和-Ⅳ" class="headerlink" title="377. 组合总和 Ⅳ"></a><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h2><blockquote>
<p>组合总和IV：在nums中任选一些数,和为target</p>
</blockquote>
<p>考虑顺序的组合问题：外循环target,内循环nums,应用状态方程3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num&lt;=i &amp;&amp; dp[i - num]&lt;INT_MAX-dp[i]) </span><br><span class="line">                dp[i] += dp[i - num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="爬楼梯问题"><a href="#爬楼梯问题" class="headerlink" title="爬楼梯问题"></a>爬楼梯问题</h2><blockquote>
<p>楼梯的阶数一共为target，一次可以走的步数为nums[i]。一共有多少种走法？</p>
</blockquote>
<p>考虑顺序的组合问题：外循环target,内循环nums,应用状态方程3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=nums[j] &amp;&amp; dp[i - nums[j]]&lt;INT_MAX-dp[i])&#123;</span><br><span class="line">                dp[i] += dp[i - nums[j]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="518-零钱兑换-II"><a href="#518-零钱兑换-II" class="headerlink" title="518. 零钱兑换 II"></a><a href="https://leetcode.cn/problems/coin-change-2/">518. 零钱兑换 II</a></h2><blockquote>
<p>零钱兑换2：任选硬币凑成指定金额,求组合总数</p>
</blockquote>
<p>完全背包不考虑顺序的组合问题：外循环coins,内循环target正序,应用转移方程3</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, vector&lt;<span class="keyword">int</span>&gt; &amp;coins)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++)</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin)</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1155-掷骰子的N种方法"><a href="#1155-掷骰子的N种方法" class="headerlink" title="1155. 掷骰子的N种方法"></a><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum/">1155. 掷骰子的N种方法</a></h2><blockquote>
<p>投掷骰子的方法数：d个骰子,每个有f个面(点数为1,2,…f),求骰子点数和为target的方法</p>
</blockquote>
<p>分组0/1背包的组合问题：dp[i][j]表示投掷i个骰子点数和为j的方法数;三层循环：最外层为背包d,然后先遍历target后遍历点数f<br>应用二维拓展的转移方程3：dp[i][j]+=dp[i-1][j-f];</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRollsToTarget</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> f, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(d + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(target + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= target; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= f &amp;&amp; j &gt;= k; k++)</span><br><span class="line">                dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">    <span class="keyword">return</span> dp[d][target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/posts/4589.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第二十九章】</strong>将欲取天下而为之，吾见其不得已。天下神器，不可为也，不可执也。为者败之，执者失之。是以圣人无为，故无败，故无失。</p>
</blockquote>
<span id="more"></span>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><blockquote>
<p>给你一个元素值<strong>互不相同</strong>的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br><span class="line">解释：原数组为 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ，旋转 <span class="number">3</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br><span class="line">解释：原数组为 [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>]</span><br><span class="line">输出：<span class="number">11</span></span><br><span class="line">解释：原数组为 [<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>] ，旋转 <span class="number">4</span> 次得到输入数组。</span><br></pre></td></tr></table></figure>
<h3 id="二分搜索法"><a href="#二分搜索法" class="headerlink" title="二分搜索法"></a>二分搜索法</h3><p>这里用中间的值 nums[mid] 和右边界值 nums[right] 进行比较，若数组没有旋转或者旋转点在左半段的时候，中间值是一定小于右边界值的，所以要去左半边继续搜索，反之则去右半段查找，最终返回 nums[right] 即可。——来自<a href="https://www.cnblogs.com/grandyang/p/4032934.html">grandyang</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>这里每次将区间 [start, end] 从中间 mid 位置分为两段，分别调用递归函数，并比较返回值，每次取返回值较小的那个即可，参见代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[start] &lt;= nums[end]) <span class="keyword">return</span> nums[start];</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">helper</span>(nums, start, mid), <span class="built_in">helper</span>(nums, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="154-寻找旋转排序数组中的最小值-II"><a href="#154-寻找旋转排序数组中的最小值-II" class="headerlink" title="154. 寻找旋转排序数组中的最小值 II"></a><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/">154. 寻找旋转排序数组中的最小值 II</a></h2><blockquote>
<p>给你一个可能存在<strong>重复</strong>元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">输出：<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">输出：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当第一个数字和最后一个数字，还有中间那个数字全部相等的时候，将右指针左移一位（或者将左指针右移一位），略过一个相同数字，这对结果不会产生影响，因为只是去掉了一个相同的，然后对剩余的部分继续用二分查找法。——来自<a href="https://www.cnblogs.com/grandyang/p/4040438.html">grandyang</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; nums[r]) &#123;</span><br><span class="line">            l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[r])&#123;</span><br><span class="line">            r = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> nums[r];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><p>不过写法跟之前那道略有不同，只有在 nums[start] &lt; nums[end] 的时候，才能返回 nums[start]，等于的时候不能返回，比如 [3, 1, 3] 这个数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == end) <span class="keyword">return</span> nums[start];</span><br><span class="line">    <span class="keyword">if</span> (nums[start] &lt; nums[end]) <span class="keyword">return</span> nums[start];</span><br><span class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">helper</span>(nums, start, mid), <span class="built_in">helper</span>(nums, mid + <span class="number">1</span>, end));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><blockquote>
<p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p>
</blockquote>
<p>可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。这启示我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid+1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分： </p>
<ul>
<li>如果 [l, mid-1] 是有序数组，且 target 的大小满足 [nums[l], nums[mid])，则我们应该将搜索范围缩小至 [l, mid-1]，否则在 [mid+1, r] 中寻找。</li>
<li>如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1], nums[r]]，则我们应该将搜索范围缩小至 [mid+1, r]，否则在 [l, mid-1] 中寻找。</li>
</ul>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/">作者：LeetCode-Solution</a></p>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>], target = <span class="number">3</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：nums = [<span class="number">1</span>], target = <span class="number">0</span></span><br><span class="line">输出：<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; nums[r]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; nums[r]&gt;=target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[l]&lt;=target &amp;&amp; nums[mid]&gt;target) r = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>历史周期律</title>
    <url>/posts/64307.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十一章】</strong> 君子居则贵左，用兵则贵右。兵者不祥之器，非君子之器，不得已而用之，恬淡为上，胜而不美，而美之者，是乐杀人。夫乐杀人者，则不可得志于天下矣。</p>
</blockquote>
<span id="more"></span>

<h2 id="李晓鹏"><a href="#李晓鹏" class="headerlink" title="李晓鹏"></a>李晓鹏</h2><h3 id="《从黄河文明到一带一路·第四卷》"><a href="#《从黄河文明到一带一路·第四卷》" class="headerlink" title="《从黄河文明到一带一路·第四卷》"></a>《从黄河文明到一带一路·第四卷》</h3><blockquote>
<p>犹太教、基督教、拜上帝教都认上帝为唯一主神，但上帝分别派了三个人来干三件不同的事：一是委托摩西管理和拯救犹太民族；二是委托耶稣来净化人类的灵魂；三是委托洪秀全来拯救中国人民。<br><br>近代中国的革命和改良，基本主线是中国人民与满清、汉族官僚士绅、外国列强三股反动势力反复博弈的过程。太平天国试图以底层革命的方式一次性推翻三大反动势力，壮烈失败。此后，满洲和汉族官僚士绅联合起来搞“洋务运动”，想以此富国强兵、抵御外辱，以甲午惨败结束。然后，义和团运动试图采取“扶清灭洋”的路线，联合国内两股势力共同抵御列强，遭到了汉族官僚的拒绝和满清的背叛，又被三大反动势力联合镇压。《辛丑条约》以后，满清全面投靠列强，倚靠列强榨取汉族士绅和中国人民的利益，结果就是汉族官僚士绅们开始跟革命党合作，以谋求终结满清专制，最终诱发了辛亥革命。</p>
</blockquote>
<h3 id="《从黄河文明到一带一路·第三卷》"><a href="#《从黄河文明到一带一路·第三卷》" class="headerlink" title="《从黄河文明到一带一路·第三卷》"></a>《从黄河文明到一带一路·第三卷》</h3><blockquote>
<p>投票式民主并不是英国的首创，雅典和威尼斯共和国这些古老的海权国家，都是搞的投票式民主。这三个时期的代表性海权国家，都主要依靠海外殖民劫掠发迹。由于它们有大量来自于海外殖民地的财富，本国内部的生存资源争夺并不激烈。其本国底层人民，也可以从海外殖民带来的财富中获利，而无需向中国古代的农民一样，完全依靠自己的努力来养活自己和整个国家。在生存资源无忧的情况下，内部斗争——不管是统治阶级内部的利益集团之间的斗争，还是统治阶级与被统治阶级之间的斗争，都会相对缓和。也就不需要一个专制君主来决定资源分配，大多数问题用投票和开会的形式也能解决。这种民主体制，本质上是一种“分赃式民主”，是强盗们为了和平分配劫掠而来的财富所建立的程序。<br><br>英国从君主专制国家走向君主立宪制国家的背景就是这样。专制时期，还没有建立海外殖民霸权，全体国民必须自己养活自己，在国家内部分配生存资源。这个时候要组织国家资源打仗，不管是殖民战争还是争霸战争，就会面临非常严峻的国内生存资源分配问题。为了保证战争的效率和分配的公平，最佳的方案就是建立独裁君主制度。独裁君主有两个作用，一个是镇压人民反抗，但还有一个很重要的作用，就是遏制贵族的贪欲，限制他们对人民的剥夺，并强迫贵族、地主、资本家这些有钱有权的阶层多出钱来支持战争。用独裁君主制代替封建制度，是英国从弱到强的关键。等到殖民战争和争霸战争打赢了，最艰难的时刻过去了，殖民统治体系建立起来了，有众多海外殖民地可供掠夺，资源分配条件变得宽松。利益集团内部，不需要进行你死我活的斗争了；统治精英们富得流油的同时，底层人民的税负也不高、福利还不错。这种情况下，专制君主就成了一个累赘。大家就觉得还是民主好，独裁君主对贵族精英们管束的太严了、收的钱太多了，让精英们很不舒服，可以搞个科学的程序来做决策，各大利益集团选择自己的代表大家开个会各抒己见就挺好的。贵族、地主、资本家就联合起来把专制君主推翻了。决策程序慢一点没关系，吵架厉害一点没关系，不会耽误大事，利益集团之间也不会当真打起来，代议制民主就取代了独裁君主制。</p>
</blockquote>
<h3 id="人治和法治"><a href="#人治和法治" class="headerlink" title="人治和法治"></a>人治和法治</h3><blockquote>
<p>一些迷信西方制度优越论的人，还进一步提出了所谓“人治”和“法治”的争议。他们认为中国的皇帝制度是人治，而西方的立宪制度是法治，法治是天生优于人治的。这种说法是不正确的，生造出一个概念将这两种制度对立起来，忽略了它们之间的共性和传承关系。一切法律都是人制定、修改并执行的，无论东方还是西方，古代还是现代，世界上都没有“法治社会”这种社会形态。<br><br>君主专制制度并不是君主决定每一件事情，它背后也是一套意识形态的法制体系作为支撑。中华帝国的每个王朝都有一套相当庞大而复杂的法律体系来支持其日常运转，对这一点有疑问的人可以读一下国内任何一个法学院的《中国法制史》教材。民众面对各种违法犯罪行为，也会下意识的问一句：“还有没有王法？”法律意识普及性很高。这里面当然存在有法不依、胡乱执法等问题，但这是任何制度下都有的问题，且其严重程度并不由制度本身决定，而跟收入水平、就业率、贫富差距、技术水平等相关，越是技术落后交通通讯不便的古代社会，执法者的违规成本越低，越容易胡乱执法；此外，它还跟统治精英距离大规模战争“换血”的时间密切相关，一般来说，时间越长，问题就越严重。<br><br>宪政民主制度也不是每一件事情都由全民投票表决，背后有无数的人在职业化的对其操纵，在美国式三权分立体制下，法官和律师勾结、官员与商人勾结、总统收钱赦免“关系户”等行为屡见不鲜，立法者受利益集团操控在法律中大量植入维护利益集团的条款，更是司空见惯。皇帝制度和西方宪政制度的差距，主要是法律制定程序的区别，在有没有法律和法律如何执行方面，则没有很大区别。利益集团一旦掌握了制定法律和执行法律的权力，法律就很难对他们构成真正的约束，这个集团的行动自由就跟皇帝和皇族差不多了。哪怕让人工智能程序来执法，统治精英们也可以悄无声息的在程序代码中写入对自己有利的漏洞，确保该程序作出有利于自己的裁决。一切法治，皆为人治；一切人治，皆有法治——没有成文法，也有习惯法。<br><br>“人治”和“法治”的争议，是一个伪问题。中国是人治或人情社会、西方是法治社会之类的说法，都是自欺欺人之言。迄今为止的一切人类文明社会形态都是人治社会，也都有法制和法治意识。人治和法制是两个层面的东西，互相之间并不矛盾，可以共同存在，而高于人治的法治则是一个臆想出来的在现实中并不存在的概念。</p>
</blockquote>
<h2 id="历史周期律"><a href="#历史周期律" class="headerlink" title="历史周期律"></a>历史周期律</h2><blockquote>
<p>历史课本告诉我们：中国封建社会存在着互相对立、彼此消长的两种土地所有制: 一是封建地主土地所有制( 包含地主阶级的国有土地制) ， 一是农民小块土地所有制。前者占支配地位， 后者为其补充。这样中国封建土地所有制实质就是封建地主土地所有制， 基本特点是土地所有权高度集中在地主阶级手中。小农经济具有其抗风险能力差的特点，普通农户家庭一旦遇到水旱蝗灾、年景歉收或是婚丧嫁娶、疾病，就不得不以土地作为抵押，从地主乡绅那里获取高利贷。<br><br>然而就像马克思和无数学者所证明的那样，历来资本的边际收益要高于劳动的边际收益，因此这就注定了在许多情况下，农民辛苦劳作所取得的收益是无法偿还高利贷的利息的。这样就在利息的“驴打滚”中恶性循环，直至将被抵押的土地偿还给地主，成为佃农，更惨一点的，就是流民。万历年间一份奏折指出：“或因水旱饥荒，及粮差繁并，或被势要相侵，及钱债驱迫，不得已将起科腴田，减其价直，典卖……”。相关的文学作品可以参考《白毛女》和茅盾先生的《春种》《秋收》。<br><br>然而，问题就来了，地主兼并农民土地，是一个线性增长财富集中愈演愈烈的趋势，但是问题就来了，因为地主士绅兼并的这些土地是不向国家交税的：<br><br>这就是造成中国封建王朝兴衰周期律的根本原因之一。土地越来越多地集中在特权阶层手中，国家能得到的赋税也就越来越少；另一方面失地流民越来越多，镇压、安抚农民起义又需要大量的财政收入，这对于封建王朝来说是一个死局。土地越集中在这些特权阶层的手中，国家受到的利益损失就越大，这就是历史上的所谓“ 锄豪强， 抑兼并”的经济思想和政策产生的经济根源。但是从公元前七年汉哀帝绥和二年颁布的封建史上的第一次限田令以来， 诸如王莽的王田制、晋初的占田制、北魏的均田制等等， 无不在既得利益的缙绅、官僚、豪强的反对下，成为一纸空文，不能实施。<br><br>来源：微信公众号”大浪淘沙”</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>人文</category>
        <category>历史</category>
      </categories>
      <tags>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>刘慈欣</title>
    <url>/posts/28106.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十章】</strong> 师之所处，荆棘生焉。大军之后，必有凶年。善有果而已，不敢以取强。果而勿矜，果而勿伐，果而勿骄，果而不得已，果而勿强。物壮则老，是谓不道，不道早已。</p>
</blockquote>
<span id="more"></span>

<h3 id="《球状闪电》"><a href="#《球状闪电》" class="headerlink" title="《球状闪电》"></a>《球状闪电》</h3><blockquote>
<p>“从物理学角度看，生命这种物质运动形式，与其他的物质运动相比并没有更高的含义，从生命中你找不到新的物理规律，所以从我的角度看，一个人的死与一块冰的消融并没有本质的区别。陈博士，你这人有时候想得太多，你应该学会从宇宙终极规律的角度看待生活，这样过得就舒服多了。”（这比宗教还超脱…）<br><br>后来发现，整个物理学就像是一个大谜，走到它的尽头，连整个世界是否存在都成了问题。<br><br>美妙人生的关键在于你能迷上什么东西。<br> <br>理想主义者和玩世不恭的人都觉得对方很可怜，可他们实际都很幸运。<br><br>“其实，儿子，过一个美妙的人生并不难，听爸爸教你：你选一个公认的世界难题，最好是只用一张纸和一只铅笔的数学难题，比如歌德巴赫猜想或费尔马大定理什么的，或连纸笔都不要的纯自然哲学难题，比如宇宙的本源之类，投入全部身心钻研，只问耕耘不问收获，不知不觉的专注中，一辈子也就过去了。人们常说的寄托，也就是这么回事。或是相反，把挣钱作为惟一的目标，所有的时间都想着怎么挣，也不问挣来干什么用，到死的时候像葛朗台一样抱者一堆金币说：啊，真暖和啊……所以，美妙人生的关键在于你能迷上什么东西。”（窃以为，绝大多数时候这种人生并不美妙…）<br><br>黄金色的树林里分出两条路，可惜我们不能同时去涉足，但我们却选择了人迹罕至的那一条，这从此决定了我们的一生。<br><br>“我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳……它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。<br>　　<br>当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。” </p>
</blockquote>
<h3 id="《三体》"><a href="#《三体》" class="headerlink" title="《三体》"></a>《三体》</h3><blockquote>
<p><strong>《三体1：地球往事》</strong><br>我们都是阴沟里的虫子,但总还是得有人仰望星空。<br>　　<br>“我只想说明以下的事实：在宇宙间，一个技术文明等级的重要标志，是它能够控制和使用的微观维度。对于基本粒子的一线使用，从我们那些长毛裸体的祖先在山洞中生起篝火时就开始了，对化学反应的控制，就是在一维层次上操控微观粒子。当然，这种控制也是从低级到高级，从篝火到后来的蒸汽机，再到后来的发电机；现在，人类对微观粒子一维控制的水平已达到了顶峰，有了计算机，也有了你们的纳米材料。但这一切，都局限于对微观维度的一维控制，在宇宙间一个更高级的文明看来，篝火和计算机、纳米材料等等是没有本质区别的，同属于一个层次，这也是他们仍将人类看成虫子的原因——遗憾的是，他们是对的。” <br><br>消灭人类暴政！世界属于三体！（源于阿尔巴尼亚电影《地下游击队》游击队员的那句“消灭法西斯，自由属于人民”）。<br><br> “射手”假说：有一名神枪手，在一个靶子上每隔十厘米打一个洞。设想这个靶子的平面上生活着一种二维智能生物，它们中的科学家在对自己的宇宙进行观察后，发现了一个伟大的定律： “宇宙每隔十厘米，必然会有一个洞。”它们把这个神枪手一时兴起的随意行为，看成了自己宇宙中的铁律。<br><br>“农场主假说”：则有一层令人不安的恐怖色彩：一个农场里有一群火鸡，农场主每天中午十一点来给它们喂食。火鸡中的一名科学家观察这个现象，一直观察了近一年都没有例外，于是它也发现了自己宇宙中的伟大定律：“每天上午十一点，就有食物降临。”它在感恩节早晨向火鸡们公布了这个定律，但这天上午十一点食物没有降临，农场主进来把它们都捉去杀了。<br><br><strong>《三体2：黑暗森林》</strong><br>“这是计划的一部分。”<br><br>第一，生存是文明的第一需要；第二，文明不断增长和扩张，但宇宙中的物质总量保持不变。<br><br> “要多想。”父亲说。<br>“想了以后呢？”章北海问。<br>“北海，我只能告诉你那以前要多想。”父亲回答。<br>爸，谢谢您。您说得很清楚了，我的心都听懂了。 <br><br> 大低谷纪念碑：给岁月以文明，而不是给文明以岁月。（给时光以生命，而不是给生命以时光——-帕斯卡） <br><br>“这…也太黑了吧…”“真实的宇宙就是这么黑。”罗辑伸手挥挥，像抚摸天鹅缄般感受着黑暗的质感，“宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼…他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男神，能做的只有一件事：开枪消灭之！在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。”大史又点上了一支烟，仅仅是为了有点光明。<br><br>“但黑暗森林中有一个叫人类的傻孩子，生了一堆火并在旁边高喊：我在这儿！我在这儿！”罗辑说。<br><br><strong>《三体3：死神永生》</strong><br>死亡是唯一一座永远亮着的灯塔，不管你向哪里航行，最终都得转向它指引的方向。一切都会逝去，只有死神永生。（如果一切都逝去了，死神的永生还有意义吗？）<br><br>前进！前进,不择手段地前进！——维德<br><br>“不要返航！这里不是家！” <br><br>维德抬头看着程心，目光中又露出了那种罕见的无助和乞求，他一字一顿地说：“失去人性，失去很多；失去兽性，失去一切。”（伟大导师恩格斯曰：人类源于动物的事实决定了人类永远不可能摆脱兽性，只是在于摆脱的多与少而已。）<br><br>低熵体不一样，低熵体的熵还在降低.有序度还在上升，像漆黑海面上升起的磷火,这就是意义，最高层的意义，比乐趣的意义层次要高。要维持这种意义，低墒体就必须存在和延续。（它的意义在于没意义…）<br><br>藏好自己，做好清理。<br><br>弱小和无知不是生存的障碍,傲慢才是。<br><br>把海弄干的鱼在海干前上了陆地，从一片黑暗森林奔向另一片黑暗森林。<br><br><a href="https://www.bilibili.com/read/cv855892/">注释作者：张北海 </a> </p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>人文</category>
        <category>科幻</category>
      </categories>
      <tags>
        <tag>人文</tag>
      </tags>
  </entry>
  <entry>
    <title>拓扑排序</title>
    <url>/posts/22315.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十二章】</strong>道常无名，朴。虽小，天下莫能臣。候王若能守之，万物将自宾。天地相合，以降甘露，民莫之令而自均。</p>
</blockquote>
<span id="more"></span>

<h2 id="210-课程表-II"><a href="#210-课程表-II" class="headerlink" title="210. 课程表 II"></a><a href="https://leetcode.cn/problems/course-schedule-ii/">210. 课程表 II</a></h2><blockquote>
<p>给一个数组 prerequisites，返回你为了学完所有课程所安排的学习顺序。</p>
</blockquote>
<p>示例 1:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: numCourses = <span class="number">2</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>]] </span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: numCourses = <span class="number">4</span>, prerequisites = [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">2</span>,<span class="number">0</span>],[<span class="number">3</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">2</span>]]</span><br><span class="line">输出: [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">or</span> [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>示例 3:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: numCourses = <span class="number">1</span>, prerequisites = [] </span><br><span class="line">输出: [<span class="number">0</span>]</span><br><span class="line">解释: 总共 <span class="number">1</span> 门课，直接修第一门课就可。</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt; &gt; graph;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegrees</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pre : prerequisites) &#123;</span><br><span class="line">            graph[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            inDegrees[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            res.<span class="built_in">push_back</span>(node);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> n : graph[node]) &#123;</span><br><span class="line">                inDegrees[n]--;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(inDegrees[n] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-II-114-外星文字典"><a href="#剑指-Offer-II-114-外星文字典" class="headerlink" title="剑指 Offer II 114. 外星文字典"></a><a href="https://leetcode.cn/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h2><blockquote>
<p>根据词典还原出此语言中已知的字母顺序，并按字母递增顺序排列。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">&quot;wrt&quot;</span>,<span class="string">&quot;wrf&quot;</span>,<span class="string">&quot;er&quot;</span>,<span class="string">&quot;ett&quot;</span>,<span class="string">&quot;rftt&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;wertf&quot;</span></span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">&quot;z&quot;</span>,<span class="string">&quot;x&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;zx&quot;</span></span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入：words = [<span class="string">&quot;z&quot;</span>,<span class="string">&quot;x&quot;</span>,<span class="string">&quot;z&quot;</span>]</span><br><span class="line">输出：<span class="string">&quot;&quot;</span></span><br><span class="line">解释：不存在合法字母顺序，因此返回 <span class="string">&quot;&quot;</span> 。</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, unordered_set&lt;<span class="keyword">char</span>&gt; &gt; graph;</span><br><span class="line">        unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; inDegrees;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!graph.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                    graph[c] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!inDegrees.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                    inDegrees[c] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; words.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> minlen = <span class="built_in">min</span>(words[i<span class="number">-1</span>].<span class="built_in">size</span>(), words[i].<span class="built_in">size</span>());</span><br><span class="line">            <span class="keyword">for</span>(; j &lt; minlen; j++) &#123;</span><br><span class="line">                <span class="keyword">char</span> c1 = words[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">char</span> c2 = words[i][j];</span><br><span class="line">                <span class="keyword">if</span>(c1 != c2) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!graph[c1].<span class="built_in">count</span>(c2)) &#123;</span><br><span class="line">                        graph[c1].<span class="built_in">insert</span>(c2);</span><br><span class="line">                        inDegrees[c2]++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(j==minlen &amp;&amp; words[i<span class="number">-1</span>].<span class="built_in">size</span>()&gt;words[i].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        string res;</span><br><span class="line">        queue&lt;<span class="keyword">char</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; d : inDegrees) &#123;</span><br><span class="line">            <span class="keyword">if</span>(d.second == <span class="number">0</span>) &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(d.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            res.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; c : graph[c]) &#123;</span><br><span class="line">                inDegrees[c]--;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(inDegrees[c] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">size</span>() != inDegrees.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="剑指-Offer-II-115-重建序列"><a href="#剑指-Offer-II-115-重建序列" class="headerlink" title="剑指 Offer II 115. 重建序列"></a><a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h2><blockquote>
<p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p>
</blockquote>
<p>示例 1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: org = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], seqs = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释：[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 不是可以被重建的唯一的序列，因为 [<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>] 也是一个合法的序列。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: org = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], seqs = [[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line">输出: <span class="literal">false</span></span><br><span class="line">解释：可以重建的序列只有 [<span class="number">1</span>,<span class="number">2</span>]。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">输入: org = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], seqs = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">输出: <span class="literal">true</span></span><br><span class="line">解释：序列 [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">3</span>] 和 [<span class="number">2</span>,<span class="number">3</span>] 可以被唯一地重建为原始的序列 [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]。</span><br></pre></td></tr></table></figure>
<p>实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; org, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, unordered_set&lt;<span class="keyword">int</span>&gt; &gt; graph;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegrees</span><span class="params">(org.size()+<span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>&amp; num : seq) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num&lt;<span class="number">1</span> || num&gt;org.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!graph.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                    graph[num] = &#123;&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(inDegrees[num] == <span class="number">-1</span>) &#123;</span><br><span class="line">                    inDegrees[num] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>()<span class="number">-1</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> num1 = seq[i];</span><br><span class="line">                <span class="keyword">int</span> num2 = seq[i+<span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!graph[num1].<span class="built_in">count</span>(num2)) &#123;</span><br><span class="line">                    graph[num1].<span class="built_in">insert</span>(num2);</span><br><span class="line">                    inDegrees[num2]++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; inDegrees.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; org[index++]==i) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(i);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> node  = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; next : graph[node]) &#123;</span><br><span class="line">                inDegrees[next]--;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(inDegrees[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(q.<span class="built_in">size</span>()==<span class="number">0</span> &amp;&amp; org[index++]==next) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(next);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> index==org.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>拓扑排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>股票买卖问题</title>
    <url>/posts/7294.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十三章】</strong>知人者智，自知者明。胜人者有力，自胜者强。知足者富，强行者有志，不失其所者久，死而不亡者寿。</p>
</blockquote>
<span id="more"></span>

<p>本文代码参考自：<a href="https://hreina.github.io/2022/05/19/%E8%82%A1%E7%A5%A8%E4%B9%B0%E5%8D%96%E9%97%AE%E9%A2%98/">HReina的博客</a></p>
<h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><blockquote>
<p>只能交易一次</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(n)</span></span>; <span class="comment">//当天不持有股票</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(n)</span></span>; <span class="comment">//当天持有股票</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp0[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp0[i]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]+prices[i]);</span><br><span class="line">            dp1[i]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>], -prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h2><blockquote>
<p>交易次数不限</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(n)</span></span>; <span class="comment">//当天没有持有股票</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(n)</span></span>; <span class="comment">//当天持有股票</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp0[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp0[i]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]+prices[i]);</span><br><span class="line">            dp1[i]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>], dp0[i<span class="number">-1</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="123-买卖股票的最佳时机-III"><a href="#123-买卖股票的最佳时机-III" class="headerlink" title="123.买卖股票的最佳时机 III"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">123.买卖股票的最佳时机 III</a></h2><blockquote>
<p>最多交易两次</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp0</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp1</span>(n,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            dp0[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">            dp1[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp0[i][j]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>][j], dp1[i<span class="number">-1</span>][j]+prices[i]);</span><br><span class="line">                dp1[i][j]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>][j], dp0[i<span class="number">-1</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="188-买卖股票的最佳时机-IV"><a href="#188-买卖股票的最佳时机-IV" class="headerlink" title="188. 买卖股票的最佳时机 IV"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h2><blockquote>
<p>最多可以交易k次</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// k = min(n/2, k);  </span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp0</span>(n,vector&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp1</span>(n,vector&lt;<span class="keyword">int</span>&gt;(k+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">            dp0[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">            dp1[<span class="number">0</span>][i]=-prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                dp0[i][j]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>][j], dp1[i<span class="number">-1</span>][j]+prices[i]);</span><br><span class="line">                <span class="comment">// 0--&gt;1：买入操作，交易次数：j-1--&gt;j</span></span><br><span class="line">                dp1[i][j]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>][j], dp0[i<span class="number">-1</span>][j<span class="number">-1</span>]-prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309. 最佳买卖股票时机含冷冻期"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></h2><blockquote>
<p>交易次数不限，含冷冻期</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp0[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">        dp0[<span class="number">1</span>]=<span class="built_in">max</span>(dp0[<span class="number">0</span>], dp1[<span class="number">0</span>]+prices[<span class="number">1</span>]);</span><br><span class="line">        dp1[<span class="number">1</span>]=<span class="built_in">max</span>(dp1[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp0[i]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]+prices[i]);</span><br><span class="line">            dp1[i]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>], dp0[i<span class="number">-2</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="714-买卖股票的最佳时机含手续费"><a href="#714-买卖股票的最佳时机含手续费" class="headerlink" title="714.买卖股票的最佳时机含手续费"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714.买卖股票的最佳时机含手续费</a></h2><blockquote>
<p>交易次数不限，含手续费</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp0</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        dp0[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">0</span>]=-prices[<span class="number">0</span>]-fee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp0[i]=<span class="built_in">max</span>(dp0[i<span class="number">-1</span>], dp1[i<span class="number">-1</span>]+prices[i]);</span><br><span class="line">            dp1[i]=<span class="built_in">max</span>(dp1[i<span class="number">-1</span>], dp0[i<span class="number">-1</span>]-prices[i]-fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp0[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>动态规划</category>
        <category>股票买卖</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU与LFU</title>
    <url>/posts/13455.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第十三章】</strong>宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下，得之若惊，失之若惊，是谓宠辱若惊。何谓贵大患若身？吾所以有大患者，为吾有身，及吾无身，吾有何患！</p>
</blockquote>
<span id="more"></span>

<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h2><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存约束的数据结构。<br>实现 LRUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 刚访问过的结点移动到链表头</span></span><br><span class="line">        lst.<span class="built_in">splice</span>(lst.<span class="built_in">begin</span>(), lst, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> m[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// key已经存在，抹去</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>()) lst.<span class="built_in">erase</span>(it-&gt;second);</span><br><span class="line">        <span class="comment">// 插入链表头</span></span><br><span class="line">        lst.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="comment">// 建立key到list迭代器的映射</span></span><br><span class="line">        m[key] = lst.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 元素个数超过缓存容量大小</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt; cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = lst.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            <span class="comment">// 删除链表末尾（最近最少使用）元素</span></span><br><span class="line">            lst.<span class="built_in">pop_back</span>();</span><br><span class="line">            m.<span class="built_in">erase</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;  </span><br><span class="line">    <span class="comment">// 链表，元素为（key，value）对</span></span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; lst;</span><br><span class="line">    <span class="comment">// 哈希表，key--&gt;（key，value）迭代器</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></h2><blockquote>
<p>请你为最不经常使用（LFU）缓存算法设计并实现数据结构。<br>实现 LFUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 将结点从freq list里摘除</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">erase</span>(iter[key]);</span><br><span class="line">        <span class="comment">// freq自增1</span></span><br><span class="line">        ++m[key].second;</span><br><span class="line">        <span class="comment">// 加入freq+1 list 表尾</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="comment">// 更新迭代器位置</span></span><br><span class="line">        iter[key] = --freq[m[key].second].<span class="built_in">end</span>();</span><br><span class="line">        <span class="comment">// 如果minFreq list 为空，则minFreq++</span></span><br><span class="line">        <span class="keyword">if</span>(freq[minFreq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            ++minFreq;</span><br><span class="line">        <span class="comment">// 返回key对应的value</span></span><br><span class="line">        <span class="keyword">return</span> m[key].first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该key之前已经存在，更新value即可</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            m[key].first = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            iter.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            freq[minFreq].<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m[key] = &#123;value, <span class="number">1</span>&#125;;</span><br><span class="line">        freq[<span class="number">1</span>].<span class="built_in">push_back</span>(key);</span><br><span class="line">        iter[key] = --freq[<span class="number">1</span>].<span class="built_in">end</span>();</span><br><span class="line">        minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 容量，最小频率</span></span><br><span class="line">    <span class="keyword">int</span> cap, minFreq;</span><br><span class="line">    <span class="comment">// key--&gt;(value, freq)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line">    <span class="comment">// freq--&gt;list of key with freq：频率为freq对应的key存在一个list里</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt; &gt; freq;</span><br><span class="line">    <span class="comment">// key--&gt;list&lt;int&gt;::iterator，保存key在对应freq list里的迭代器，为了实现查找O(1)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;::iterator&gt; iter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>LRU</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵中的最长递增路径</title>
    <url>/posts/31989.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十四章】</strong>大道汜兮，其可左右。万物恃之以生而不辞，功成而不有。衣养万物而不为主，常无欲，可名于小；万物归焉而不为主，可名为大。以其终不自为大，故能成其大。</p>
</blockquote>
<span id="more"></span>

<h2 id="329-矩阵中的最长递增路径"><a href="#329-矩阵中的最长递增路径" class="headerlink" title="329. 矩阵中的最长递增路径"></a><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h2><blockquote>
<p>给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(matrix, i, j, dp));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; matrix, <span class="keyword">int</span> i, <span class="keyword">int</span> j, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; dp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp[i][j]++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nexti = i+dirs[k][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nextj = j+dirs[k][<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nexti&gt;=<span class="number">0</span> &amp;&amp; nexti&lt;m &amp;&amp; nextj&gt;=<span class="number">0</span> &amp;&amp; nextj&lt;n &amp;&amp; matrix[nexti][nextj]&gt;matrix[i][j]) &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], <span class="built_in">dfs</span>(matrix, nexti, nextj, dp)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排列组合问题</title>
    <url>/posts/49159.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十五章】</strong>执大象，天下往。往而不害，安平太。乐与饵，过客止，道之出口，淡乎其无味，视之不足见，听之不足闻，用之不足既。</p>
</blockquote>
<span id="more"></span>

<h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><blockquote>
<p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> *visted = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="built_in">fill</span>(visted, visted+n, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(nums, res, out, visted);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">bool</span>* visted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visted[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        out.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        visted[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, res, out, visted);</span><br><span class="line">        visted[i] = <span class="literal">false</span>;</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-全排列-II"><a href="#47-全排列-II" class="headerlink" title="47. 全排列 II"></a><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></h2><blockquote>
<p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">bool</span>* visted, vector&lt;<span class="keyword">int</span>&gt;&amp; cur, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="built_in">size</span>() &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visted[i] || (i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; visted[i<span class="number">-1</span>]==<span class="literal">false</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        vis[i] = <span class="number">1</span>;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, visted, cur, res);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">bool</span> *visted = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">fill</span>(visted, visted+n, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(nums, visted, cur, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><blockquote>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = n<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j = n<span class="number">-1</span>; j &gt;= i; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[j] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[j], nums[i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>()+i, nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="牛客BM58-字符串的排列"><a href="#牛客BM58-字符串的排列" class="headerlink" title="牛客BM58. 字符串的排列"></a><a href="https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=295&tags=&title=&difficulty=0&judgeStatus=0&rp=0&sourceUrl=/exam/oj?page=1&tab=%25E7%25AE%2597%25E6%25B3%2595%25E7%25AF%2587&topicId=295">牛客BM58. 字符串的排列</a></h2><blockquote>
<p>输入一个长度为 n 字符串，打印出该字符串中字符的所有排列。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = str.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string cur;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> *visited = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line">    <span class="built_in">fill</span>(visited, visited+n, <span class="literal">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(str, res, cur, visited);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(string&amp; str, vector&lt;string&gt;&amp; res, string&amp; cur, <span class="keyword">bool</span>* visited)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur.<span class="built_in">size</span>() == str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[i] == <span class="literal">true</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; str[i]==str[i<span class="number">-1</span>] &amp;&amp; visited[i<span class="number">-1</span>]==<span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        cur.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(str, res, cur, visited);</span><br><span class="line">        cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        visited[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h2><blockquote>
<p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(n, k, res, out, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(out.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        out.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(n, k, res, out, i+<span class="number">1</span>);</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><blockquote>
<p>找出nums（无重复）中可以使数字和为目标数target的所有不同组合。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(nums, target, res, out, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        out.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(nums, target-nums[i], res, out, i);</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-组合总和II"><a href="#40-组合总和II" class="headerlink" title="40. 组合总和II"></a><a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和II</a></h2><blockquote>
<p>组合总和带重复元素。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(candidates, target, res, out, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;start &amp;&amp; candidates[i]==candidates[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        out.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target-candidates[i], res, out, i+<span class="number">1</span>);</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="216-组合总和-III"><a href="#216-组合总和-III" class="headerlink" title="216. 组合总和 III"></a><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></h2><blockquote>
<p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：1、只使用数字1到9每个数字；2、最多使用一次。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="keyword">int</span> k, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(k, n, res, out, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt;&amp; res, vector&lt;<span class="keyword">int</span>&gt;&amp; out, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span> &amp;&amp; out.<span class="built_in">size</span>()==k) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(out);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        out.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">dfs</span>(k, n-i, res, out, i+<span class="number">1</span>);</span><br><span class="line">        out.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="377-组合总和IV"><a href="#377-组合总和IV" class="headerlink" title="377. 组合总和IV"></a><a href="https://leetcode.cn/problems/combination-sum-iv/">377. 组合总和IV</a></h2><blockquote>
<p>从不同整数组成的数组nums中找出并返回总和为 target 的元素组合的个数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num&lt;=i &amp;&amp; dp[i-num]&lt;INT_MAX-dp[i]) </span><br><span class="line">                dp[i] += dp[i-num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>N皇后问题</title>
    <url>/posts/37262.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十六章】</strong>将欲歙之，必固张之；将欲弱之，必固强之；将欲废之，必固兴之；将欲取之，必固与之。是谓微明，柔弱胜刚强。鱼不可脱于渊，国之利器不可以示人。</p>
</blockquote>
<span id="more"></span>

<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><blockquote>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(res, board, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;string&gt; &gt;&amp; res, vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(board);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = board[row].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isValid</span>(board, row, col)) <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(res, board, row+<span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>, j = col<span class="number">-1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>, j = col+<span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="52-N皇后-II"><a href="#52-N皇后-II" class="headerlink" title="52. N皇后 II"></a><a href="https://leetcode.cn/problems/n-queens-ii/">52. N皇后 II</a></h2><blockquote>
<p>给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">        <span class="built_in">dfs</span>(board, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span>&amp; res, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(row == n) &#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; ++col) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">isValid</span>(board, row, col)) <span class="keyword">continue</span>;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(board, res, row+<span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>, j = col+<span class="number">1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&lt;n; --i, ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = row<span class="number">-1</span>, j = col<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; --i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>回溯</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/posts/41689.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十七章】</strong>道常无为而无不为。候王若能守之，万物将自化。化而欲作，吾将镇之以无名之朴，镇之以无名之朴，夫将不欲。不欲以静，天下将自定。</p>
</blockquote>
<span id="more"></span>

<h2 id="剑指-Offer-II-041-滑动窗口的平均值"><a href="#剑指-Offer-II-041-滑动窗口的平均值" class="headerlink" title="剑指 Offer II 041. 滑动窗口的平均值"></a><a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></h2><blockquote>
<p>给定一个整数数据流和一个窗口大小，计算滑动窗口里所有数字的平均值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MovingAverage</span>(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        sz = size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.<span class="built_in">size</span>() == sz) &#123;</span><br><span class="line">            sum -= dq.<span class="built_in">front</span>();</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum += val;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sum/dq.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="keyword">double</span>&gt; dq;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MovingAverage* obj = new MovingAverage(size);</span></span><br><span class="line"><span class="comment"> * double param_1 = obj-&gt;next(val);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><blockquote>
<p>求滑动窗口最大值</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;k || k&lt;<span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        deque&lt;<span class="keyword">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[dq.<span class="built_in">back</span>()]&lt;nums[i]) &#123;</span><br><span class="line">                dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(dq.<span class="built_in">front</span>()+k == i) &#123;</span><br><span class="line">                dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k<span class="number">-1</span>) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水问题</title>
    <url>/posts/9554.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十八章·上】</strong>上德不德，是以有德；下德不失德，是以无德。上德无为而无以为；下德无为而有以为。上仁为之而无以为；上义为之而有以为。上礼为之而莫之应，则攘臂而扔之。</p>
</blockquote>
<span id="more"></span>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><blockquote>
<p>给定 n 个非负整数表示的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxL = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            maxL = <span class="built_in">max</span>(maxL, height[l]);</span><br><span class="line">            maxR = <span class="built_in">max</span>(maxR, height[r]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(maxL &lt; maxR) &#123;</span><br><span class="line">                ans += maxL-height[l++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans += maxR-height[r--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>接雨水</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树公共祖先问题</title>
    <url>/posts/53911.html</url>
    <content><![CDATA[<blockquote>
<p><strong>【道德经·第三十八章·中】</strong>故失道而后德，失德而后仁，失仁而后义，失义而后礼。夫礼者，忠信之薄，而乱之首。前识者，道之华，而愚之始。</p>
</blockquote>
<span id="more"></span>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root==p || root==q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode *l = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode *r = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(l &amp;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!l &amp;&amp; !r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l==<span class="literal">nullptr</span> ? r : l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/">235. 二叉搜索树的最近公共祖先</a></h2><blockquote>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;val&gt;p-&gt;val &amp;&amp; cur-&gt;val&gt;q-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(cur-&gt;val&lt;p-&gt;val &amp;&amp; cur-&gt;val&lt;q-&gt;val) &#123;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
