<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树的遍历</title>
    <url>/posts/12682.html</url>
    <content><![CDATA[<blockquote>
<p>总结二叉树递归、非递归的前序、中序和后序遍历算法。</p>
</blockquote>
<span id="more"></span>

<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><h3 id="递归遍历方法"><a href="#递归遍历方法" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PreOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法"><a href="#非递归遍历方法" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        node *p = stk.<span class="built_in">top</span>(); stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            stk.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><h3 id="递归遍历方法-1"><a href="#递归遍历方法-1" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;left);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">    <span class="built_in">InOrder</span>(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-1"><a href="#非递归遍历方法-1" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    TreeNode *p = node;</span><br><span class="line">    <span class="keyword">while</span>(p || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TreeNode *p = stk.<span class="built_in">top</span>(); </span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><h3 id="递归遍历方法-2"><a href="#递归遍历方法-2" class="headerlink" title="递归遍历方法"></a>递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;left);</span><br><span class="line">    <span class="built_in">PostOrder</span>(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="非递归遍历方法-2"><a href="#非递归遍历方法-2" class="headerlink" title="非递归遍历方法"></a>非递归遍历方法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk1, stk2;</span><br><span class="line">    stk1.<span class="built_in">push</span>(node);</span><br><span class="line">    <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk1.<span class="built_in">top</span>();</span><br><span class="line">        stk1.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        stk2.<span class="built_in">push</span>(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            stk1.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stk2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = stk2.<span class="built_in">top</span>();</span><br><span class="line">        stk2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left) </span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right)</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!-- # 线索化二叉树 -->

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的个人博客网站(Github+Hexo+Next)</title>
    <url>/posts/10121.html</url>
    <content><![CDATA[<blockquote>
<p>Hexo博客搭建及主题美化，来自<a href="https://yuumiy.github.io/posts/2789.html">岛田悠米的博客。</a></p>
</blockquote>
<!-- ![](hello.jpg) -->

<span id="more"></span>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<blockquote>
<p>学习使用Hexo+Next搭建博客网站，这是第一篇博客！<br>文章将有以下分类：工具、技术、笔记、思考、生活、阅读、音乐。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>工具</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找中的lower_bound、upper_bound</title>
    <url>/posts/701.html</url>
    <content><![CDATA[<blockquote>
<p>总结一下二分查找细节及lower_bound、upper_bound问题。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本的二分搜索"><a href="#基本的二分搜索" class="headerlink" title="基本的二分搜索"></a>基本的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩右边界，锁定左边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  <span class="comment">// 循环结束条件：left=right+1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left&gt;=nums.<span class="built_in">size</span>() || nums[left]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>；</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为[left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，收缩左侧边界，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(right&lt;<span class="number">0</span> || nums[right]!=target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分查找</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/posts/62992.html</url>
    <content><![CDATA[<blockquote>
<p>这是一个程序员人均手撕快排、堆排序的时代0.0。</p>
</blockquote>
<span id="more"></span>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序是一种简单直观的排序方法，其基本思想是每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。<br>由插入排序的的思想可以引申出三个重要的排序算法：<em>直接插入排序</em>、<em>折半插入排序</em>和<em>希尔排序</em>。下面依次进行介绍~</p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InserSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];  <span class="comment">// nums[0]哨兵，不存放元素</span></span><br><span class="line">            <span class="keyword">for</span>(j = i<span class="number">-1</span>; nums[<span class="number">0</span>] &lt; nums[j]; --j)</span><br><span class="line">                nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[<span class="number">0</span>];  <span class="comment">// 复制nums[0]到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：最好情况O(n)，最坏情况O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)； <strong>稳定性</strong>：由于每次插入元素时总是从后往前先比较再移动，所以不会出现相等元素相对位置发生变化的情况，即直接插入排序是一种稳定的排序方法</p>
</blockquote>
<h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> low, high, mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        low = <span class="number">1</span>;</span><br><span class="line">        high = i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">            mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] &lt; nums[mid]) high = mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= high+<span class="number">1</span>; --j)</span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">        nums[high+<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：折半插入排序仅减少了比较元素的次数，而元素的移动次数并未改变，因此时间复杂度仍为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = dk+<span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[i-dk]) &#123;</span><br><span class="line">                nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">                <span class="keyword">for</span>(j = i-dk; j&gt;<span class="number">0</span> &amp;&amp; nums[<span class="number">0</span>]&lt;nums[j]; j -= dk)</span><br><span class="line">                    nums[j+dk] = nums[j];</span><br><span class="line">                nums[j+dk] = nums[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>：n在某个特定范围内时，希尔排序时间复杂度为O(n<sup>1.3</sup>)，最坏情况下复杂度为O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><p>所谓交换，就是指根据序列中两个元素的比较结果来对换这两个记录在序列中的位置。交换排序的算法很多，本文主要介绍冒泡排序和快速排序。</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j<span class="number">-1</span>] &gt; nums[j]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[j<span class="number">-1</span>], nums[j]);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">false</span>) <span class="keyword">return</span>;  <span class="comment">// 本趟没有发生交换，说明序列已经有序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(n)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序是对冒泡排序的一种改进，其基本思想是基于分治法。在待排序表L[1…n]中任取一个元素pivot作为基准，通过一趟排序算法将待排序表划分为独立的两部分L[1…k-1]和L[k+1…n]，使得L[1…k-1]中的所有元素小于pivot，L[k+1…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一趟快速排序。而后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素都放在了其最终位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = nums[low];  <span class="comment">// 第一个元素设为枢轴，对表进行划分</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;  </span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[high]&gt;=pivot) --high;</span><br><span class="line">        nums[low] = nums[high];  <span class="comment">// 将比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; nums[low]&lt;=pivot) ++low;</span><br><span class="line">        nums[high] = nums[low];  <span class="comment">// 将比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[low] = pivot;  <span class="comment">// 枢轴元素存放到最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;  <span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = <span class="built_in">Partition</span>(nums, lowm, high);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, low, pivotpos<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(nums, pivotpos+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 最好情况下为O(nlogn)，最坏情况下O(n<sup>2</sup>)；<strong>空间复杂度</strong>: 最好情况下为(logn)，最坏情况下O(n)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序基本思想是：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟做完，待排序元素只剩下1个。选择排序中的堆排序是考察的重点。</p>
<h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[i]) </span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(min != i) <span class="built_in">swap</span>(nums[i], nums[min])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>建立大根堆的算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, i, len);  <span class="comment">// 从i=[n/2]~1，反复调整堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆向下调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> k, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i &lt;= len; i *= <span class="number">2</span>) &#123;  <span class="comment">// 沿k较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;len &amp;&amp; nums[i]&lt;nums[i+<span class="number">1</span>])</span><br><span class="line">            i++;                          <span class="comment">// 取k较大的子节点的下标</span></span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;=nums[i]) <span class="keyword">break</span>;       <span class="comment">// 筛选结束</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = nums[i];            <span class="comment">// 将nums[i]调整到双亲节点上</span></span><br><span class="line">            k = i;                        <span class="comment">// 修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>]                     <span class="comment">// 被筛选节点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是堆排序算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">BuildMaxHeap</span>(nums, len);              <span class="comment">// 初始建堆</span></span><br><span class="line">    <span class="keyword">for</span>(i = len; i &gt; <span class="number">1</span>; i--) &#123;            </span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">1</span>]);           <span class="comment">// 输出堆顶元素（和堆底元素交换）</span></span><br><span class="line">        <span class="built_in">AdjustDown</span>(nums, <span class="number">1</span>, i<span class="number">-1</span>);         <span class="comment">// 整理，把剩下的i-1个元素整理成堆</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对堆进行插入操作时，先将新节点放在堆的末端，再对这个新节点执行向上调整操作。<br>下面是堆的向上调整算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustUp</span><span class="params">(<span class="keyword">int</span> nums[], inr k)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 参数k为向上调整的节点，也为堆的元素个数</span></span><br><span class="line">    nums[<span class="number">0</span>] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i = k/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]&lt;nums[<span class="number">0</span>]) &#123;</span><br><span class="line">        nums[k] = nums[i];</span><br><span class="line">        k = i;</span><br><span class="line">        i = i/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nums[k] = nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 建堆时间复杂度O(n)，每次调整时间复杂度O(h)，故在最好、最坏和平均情况下堆排序时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: O(1)；<strong>稳定性</strong>：不稳定</p>
</blockquote>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>递归形式的2路归并排序算法是基于分治的其过程如下：<br>分解：将含有n个元素的待排序表分成含n/2个元素的子表，采用2路归并排序算法对两个子表递归地进行排序。<br>合并：合并两个已经排序的子表得到排序结果。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> nums[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;       </span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, low, mid);</span><br><span class="line">        <span class="built_in">MergeSort</span>(nums, mid+<span class="number">1</span>, high);</span><br><span class="line">        <span class="built_in">Merge</span>(nums, low, mid, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *_copy = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n+<span class="number">1</span>)*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> nums, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = low; k &lt; high; k++) </span><br><span class="line">        _copy[k] = nums[k];</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=low, j=mid+<span class="number">1</span>, k=i; i&lt;=mid &amp;&amp; j&lt;=high; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_copy[i] &lt;= _copy[j])</span><br><span class="line">            nums[k] = _copy[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[k] = _copy[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) nums[k++] = _copy[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) nums[k++] = _copy[j++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>时间复杂度</strong>: 每趟归并时间复杂度为O(n)，共需logn趟归并，所以算法时间复杂度为O(nlogn)；<strong>空间复杂度</strong>: 辅助空间占用n个单元，故空间复杂度为O(n)；<strong>稳定性</strong>：稳定</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>华语流行乐教父罗大佑神级歌词</title>
    <url>/posts/47257.html</url>
    <content><![CDATA[<blockquote>
<p>华语流行乐教父——罗大佑的那些不朽的作品。</p>
</blockquote>
<span id="more"></span>

<h2 id="恋曲1990"><a href="#恋曲1990" class="headerlink" title="恋曲1990"></a>恋曲1990</h2><blockquote>
<p>乌溜溜的黑眼珠<br>和你的笑脸<br>怎么也难忘记你<br>容颜的转变<br>轻飘飘的旧时光<br>就这么溜走<br>转头回去看看时<br>已匆匆数年<br>苍茫茫的天涯路<br>是你的飘泊<br>寻寻觅觅长相守<br>是我的脚步<br>黑漆漆的孤枕边<br>是你的温柔<br>醒来时的清晨里<br>是我的哀愁<br>或许明日太阳西下<br>倦鸟已归时<br>你将已经踏上<br>旧时的归途<br>人生难得再次寻觅<br>相知的伴侣<br>生命终究难舍<br>蓝蓝的白云天<br>轰隆隆的雷雨声<br>在我的窗前<br>怎么也难忘记你<br>离去的转变<br>孤单单的身影后<br>寂寥的心情<br>永远无怨的<br>是我的双眼</p>
</blockquote>
<h2 id="爱的箴言"><a href="#爱的箴言" class="headerlink" title="爱的箴言"></a>爱的箴言</h2><blockquote>
<p>我将真心付给了你<br>将悲伤留给我自己<br>我将青春付给了你<br>将岁月留给我自己<br>我将生命付给了你<br>将孤独留给我自己<br>我将春天付给了你<br>将冬天留给我自己<br><br>爱是没有人能了解的东西<br>爱是永恒的旋律<br>爱是欢笑泪珠飘落的过程<br>爱曾经是我也是你</p>
</blockquote>
<h2 id="光阴的故事"><a href="#光阴的故事" class="headerlink" title="光阴的故事"></a>光阴的故事</h2><blockquote>
<p>春天的花开秋天的风<br>以及冬天的落阳<br>忧郁的青春年少的我<br>曾经无知的这么想<br>风车在四季轮回的歌里<br>它天天地流转<br>风花雪月的诗句里<br>我在年年的成长<br>流水它带走光阴的故事<br>改变了一个人<br>就在那多愁善感而初次<br>等待的青春<br>发黄的相片古老的信<br>以及褪色的圣诞卡<br>年轻时为你写的歌<br>恐怕你早已忘了吧<br>过去的誓言就象那课本里<br>缤纷的书签<br>刻划着多少美丽的诗<br>可是终究是一阵烟<br>流水它带走光阴的故事<br>改变了两个人<br>就在那多愁善感而初次<br>流泪的青春<br>遥远的路程昨日的梦<br>以及远去的笑声<br>再次的见面我们又历经了<br>多少的路程<br>不再是旧日熟悉的我<br>有着旧日狂热的梦<br>也不是旧日熟悉的你<br>有着依然的笑容<br>流水它带走光阴的故事<br>改变了我们<br>就在那多愁善感而初次<br>回忆的青春</p>
</blockquote>
<h2 id="童年"><a href="#童年" class="headerlink" title="童年"></a>童年</h2><blockquote>
<p>池塘边的榕树上<br>知了在声声叫着夏天<br>操场边的秋千上<br>只有蝴蝶停在上面<br>黑板上老师的粉笔<br>还在拼命叽叽喳喳写个不停<br>等待着下课等待着放学<br>等待游戏的童年<br><br>福利社里面什么都有<br>就是口袋里没有半毛钱<br>诸葛四郎和魔鬼党<br>到底谁抢到那支宝剑<br>隔壁班的那个女孩<br>怎么还没经过我的窗前<br>嘴里的零食手里的漫画<br>心里初恋的童年<br><br>总是要等到睡觉前<br>才知道功课只做了一点点<br>总是要等到考试以后<br>才知道该念的书都没有念<br>一寸光阴一寸金<br>老师说过寸金难买寸光阴<br>一天又一天一年又一年<br>迷迷糊糊的童年<br><br>没有人知道为什么<br>太阳总下到山的那一边<br>没有人能够告诉我<br>山里面有没有住着神仙<br>多少的日子里总是<br>一个人面对着天空发呆<br>就这么好奇就这么幻想<br>这么孤单的童年<br><br>阳光下蜻蜓飞过来<br>一片片绿油油的稻田<br>水彩蜡笔和万花筒<br>画不出天边那一条彩虹<br>什么时候才能像高年级的同学<br>有张成熟与长大的脸<br>盼望着假期盼望着明天<br>盼望长大的童年<br><br>一天又一天一年又一年<br>盼望长大的童年 </p>
</blockquote>
<h2 id="东方之珠"><a href="#东方之珠" class="headerlink" title="东方之珠"></a>东方之珠</h2><blockquote>
<p>小河弯弯向南流<br>流到香江去看一看<br>东方之珠<br>我的爱人<br>你的风采是否浪漫依然<br>月儿弯弯的海港<br>夜色深深<br>灯火闪亮<br>东方之珠<br>整夜未眠<br>守着沧海桑田<br>变幻的诺言<br>让海风吹拂了五千年<br>每一滴泪珠<br>仿佛都说出<br>你的尊严<br>让海潮伴我来保佑你<br>请别忘记我<br>永远不变<br>黄色的脸<br><br>船儿弯弯<br>入海港<br>回头望望<br>沧海茫茫<br>东方之珠<br>拥抱着我<br>让我温暖<br>你那苍凉的胸膛</p>
</blockquote>
<h2 id="亚细亚的孤儿"><a href="#亚细亚的孤儿" class="headerlink" title="亚细亚的孤儿"></a>亚细亚的孤儿</h2><blockquote>
<p>亚细亚的孤儿<br>在风中哭泣<br>黄色的脸孔<br>有红色的污泥<br>黑色的眼珠<br>有白色的恐惧<br>西风在东方<br>唱着悲伤的歌曲<br>亚细亚的孤儿<br>在风中哭泣<br>没有人要和你<br>玩平等的游戏<br>每个人都想要<br>你心爱的玩具<br>亲爱的孩子<br>你为何哭泣<br><br>多少人在追寻<br>那解不开的问题<br>多少人在深夜里<br>无奈地叹息<br>多少人的眼泪<br>在无言中抹去<br>亲爱的母亲<br>这是什么道理<br>亲爱的母亲<br>这是什么真理</p>
</blockquote>
<h2 id="盲聋"><a href="#盲聋" class="headerlink" title="盲聋"></a>盲聋</h2><blockquote>
<p>我知道你听不到我的歌声<br>你也看不到这世界<br>也许你不了解有多少<br>愿意关怀你的人们<br>或许你早已适应了<br>黑暗的生存<br>或许你不愿接受<br>同情的滋润<br>来自庸俗的人<br><br>我知道他听得到我的歌声<br>他也看得清这世界<br>可是昨日的信仰<br>已变成了过去<br>狂热犹存的余温<br>人们欢聚在闹市里<br>喧嚣的霓虹灯<br>破落的庭院的主人<br>也成了回忆中<br>我们遗忘的人<br><br>有人因为失去了生命<br>而得到了不灭的永恒<br>有人为了生存而出卖了<br>他们可贵的灵魂<br>心中深处的天平上<br>你的欲望与真理在斗争<br>曾经一度自诩聪明的你<br>是个迷惑的人<br></p>
</blockquote>
<h2 id="现象七十二变"><a href="#现象七十二变" class="headerlink" title="现象七十二变"></a>现象七十二变</h2><blockquote>
<p>眼看着高楼盖得越来越高<br>我们的人情味却越来越薄<br>朋友之间越来越有礼貌<br>只因为大家见面越来越少<br>苹果价钱卖得没以前高<br>或许现在味道变得不好<br>就像彩色的电视变得更加花俏<br>能辨别黑白的人越来越少<br><br>是个什么样的心理因素<br>每年要吃掉一条高速公路<br>在西门町（台北）的天桥上面闲逛<br>有多少文明人在人行道上<br>就像我看到文明车辆横冲直撞<br>我不懂大家心中作何感想<br>一年过了又是新的一年<br>每一年现代都在传统边缘<br>在每个新的一年三百六十五天<br>我们都每天进步一点点</p>
</blockquote>
<h2 id="稻草人"><a href="#稻草人" class="headerlink" title="稻草人"></a>稻草人</h2><blockquote>
<p>终日面对着青山<br>终日面对着稻浪<br>午后的云雀背着艳阳<br>那样飞<br>那样笑<br>那样歌唱<br>轻风吹在我身上<br>雨珠打在我脸上<br>午后的牛羊凝向远方<br>彩虹画出的希望<br><br>蓝蓝的青空在上<br>却有着云雀与彩虹的梦<br>多像不知足的云四处飘荡<br>何处是我的归宿<br>是否在天际的那一端<br>奇怪着稻草的身躯如何飞翔<br><br>终日面对着青山<br>终日面对着稻浪<br>晨光<br>露珠<br>夕阳<br>星辰<br>春耕<br>秋收<br>冬藏</p>
</blockquote>
<h2 id="牧童"><a href="#牧童" class="headerlink" title="牧童"></a>牧童</h2><blockquote>
<p>牛背上的牧童<br>敞开你的胸扉<br>三月的苍茫<br>掩不住你树影下菊色的梦<br>风在林梢叹息<br>云在碧空飘逸<br>你冷漠的笛声<br>掠过青草带来泥土的芳香<br>九月的诗<br>早已埋藏在风雪之中<br>为何我听到<br>你胸口里热血汹涌<br>你看那<br>千古的泉水在山谷回旋<br>可知道<br>青鸟在树林呼唤你<br>牧童<br>田园已经荒芜<br>斜阳依然孤独<br>且让你的冷漠<br>投影在那泼墨残痕的归途</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>音乐</category>
        <category>罗大佑</category>
      </categories>
      <tags>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔</title>
    <url>/posts/43432.html</url>
    <content><![CDATA[<blockquote>
<p>近期读书时摘抄的的一些使人眼前一亮的观点^.^。</p>
</blockquote>
<span id="more"></span>
<h2 id="叔本华"><a href="#叔本华" class="headerlink" title="叔本华"></a>叔本华</h2><blockquote>
<p>我们读书时，是别人在代替我们思想，我们只不过重复他的思想活动的过程而已，犹如儿童启蒙习字时，用笔按照教师以铅笔所写的笔画依样画葫芦一般。我们的思想活动在读书时被免除了一大部分。因此，我们暂不自行思索而拿书来读时，会觉得很轻松，然而在读书时，我们的头脑实际上成为别人思想的运动场了。所以，读书愈多，或整天沉浸读书的人，虽然可借以休养精神，但他的思维能力必将渐次丧失，此犹如时常骑马的人步行能力必定较差，道理相同。<br><br>生命是一团欲望，欲望不能满足便痛苦，满足便无聊，人生就在痛苦和无聊之间摇摆。<br><br>一个人只有在独处时才能成为自己。谁要是不爱独处，那他就不爱自由，因为一个人只有在独处时才是真正自由的。<br><br>社交聚会要求人们做出牺牲，而一个人越具备独特的个性，那他就越难做出这样的牺牲。因此，一个人逃避、忍受抑或喜爱独处是和这一个人自身具备的价值恰成比例。因为在独处的时候，一个可怜虫就会感受到自己的全部可怜之处，而一个具有丰富思想的人只会感觉到自己丰富的思想。<br><br>学会在人群中保持一定程度上的孤独，不要有什么想法就立马告诉别人。另外，对别人所说的话千万不要太过当真。不能对别人有太多的期待，无论在道德上抑或在思想上。对于别人的看法，应锻炼出一副淡漠、无动于衷的态度，因为这是培养值得称道的宽容的一个最切实可行的手段。<br></p>
</blockquote>
<h2 id="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"><a href="#知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？" class="headerlink" title="知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？"></a>知乎：为什么人们在夜晚看到满天的繁星会觉得幸福？</h2><blockquote>
<p>很多人意识不到，头顶的星空，才是生命最终极的意义所在，而我们的生活，不过是附属品而已。<br><br>低头看看你的手上的皮肤，上面的某一个原子，它来自你几天前吃下的一块牛肉，那头牛吃过一根草，这根草吸收了一片草原中的某些成分，这些成分是被一座远古火山喷出来的，那座火山喷出的都是地球内部的岩浆，这些岩浆在地球形成之前只是太阳系中的粉尘，这些粉尘来自一片星云，这片星云则来自太阳的前身星——一颗蓝巨星——垂死时产生的超新星爆发。而这颗蓝巨星诞生于更早的几亿年之前的第二代恒星死亡后的遗骸中，一直追朔到宇宙刚诞生的时候，所有这些东西都是一些夸克、胶子….你身体中所有大于铁的原子，都诞生于某颗超新星生命的最后时刻。<br><br>所以，说我们是星空的孩子，那是一点都不错的。可是你看看现在的人们，从他们的意识中，找得到一点和这有关的东西吗？找不到。人们只会关心当下的事，因为这和自己的切身利益直接相关，人们关心钱，关心亲人、爱人，关心工作，关心房价，关心友情，关心天气，将所有人类大脑与人类社会相互交杂后的必然产物掰开揉碎了分析得入木三分，然后按一种似乎是约定俗成的规则去做对自己最有利的事，将生活这一概念放大到无限大，占据了一个人内心的全部。<br><br>在这样一种大环境中，在某个晴朗无云的夜晚，在某个远离城市的静谧草原，你抬起头，一片明亮、壮丽、优雅、安详、神秘的广阔星空如一张巨幕赫然呈现在眼前，如一丝清雨将你世俗的双眼洗刷得干净透彻，什么都不剩，你与你最本质的归属之间再无任何隔阂，只有不断涌入眼中的无数星光直接打入你的内心。你怎能不感动？怎能不幸福？怎能不惊叹于世界之外这超越一切的最终极的美？这时你才意识到，你是社会的，但首先是自然的。<br><br>作者：<a href="https://www.zhihu.com/question/28006748/answer/39013684">萤火一号：</a><br><br>来源：知乎</p>
</blockquote>
<h2 id="《哲学九讲》节选"><a href="#《哲学九讲》节选" class="headerlink" title="《哲学九讲》节选"></a>《哲学九讲》节选</h2><blockquote>
<p>对于唯物主义，不管是哪种形式的唯物主义，一元论还是多元论，我们必须指出的是，物质性本体的观点到最后只能是精神上的自杀。如果构成整个宇宙的都是无意识的东西，那么我们称之为思想的东西以及思想活动，如果不能算是纯粹的物质，就只能是和热量、运动一样，作为其他物质实体的一种表现。思想与热量和运动将毫无差别，同样，我们也没有理由认为思想比温度或速度更重要。如果说思想只是某个物质实体一系列性质的表现，那它在物质上的意义就将等同于热量，而在精神上，则没有任何意义。而其所有成果，包括唯物主义本身在内，都将毫无意义，也毫无作用可言了。如果思想只是物质状态的产物，那么也就不会有什么至高无上的真理和唯物主义理论是否正确这样的问题了。所有的东西都只是像冰、水和水蒸气一样的存在，说唯物主义比唯心主义更正确，就好比说冰比水蒸气更真实一样没有意义，因为连真理这个词都是没有意义的。怀疑论者陷入了这么一个困境：如果他要否认所有观点和我们寻求真理的可能性，那他就必须同时否认支撑他去怀疑的观点，以及他意识到自己观点正确性的可能。而唯物主义者面临的困境也同样严峻。</p>
</blockquote>
<h2 id="李晓鹏《从黄河文明到一带一路·第四卷》"><a href="#李晓鹏《从黄河文明到一带一路·第四卷》" class="headerlink" title="李晓鹏《从黄河文明到一带一路·第四卷》"></a>李晓鹏《从黄河文明到一带一路·第四卷》</h2><blockquote>
<p>投票式民主并不是英国的首创，雅典和威尼斯共和国这些古老的海权国家，都是搞的投票式民主。这三个时期的代表性海权国家，都主要依靠海外殖民劫掠发迹。由于它们有大量来自于海外殖民地的财富，本国内部的生存资源争夺并不激烈。其本国底层人民，也可以从海外殖民带来的财富中获利，而无需向中国古代的农民一样，完全依靠自己的努力来养活自己和整个国家。在生存资源无忧的情况下，内部斗争——不管是统治阶级内部的利益集团之间的斗争，还是统治阶级与被统治阶级之间的斗争，都会相对缓和。也就不需要一个专制君主来决定资源分配，大多数问题用投票和开会的形式也能解决。这种民主体制，本质上是一种“分赃式民主”，是强盗们为了和平分配劫掠而来的财富所建立的程序。<br><br>英国从君主专制国家走向君主立宪制国家的背景就是这样。专制时期，还没有建立海外殖民霸权，全体国民必须自己养活自己，在国家内部分配生存资源。这个时候要组织国家资源打仗，不管是殖民战争还是争霸战争，就会面临非常严峻的国内生存资源分配问题。为了保证战争的效率和分配的公平，最佳的方案就是建立独裁君主制度。独裁君主有两个作用，一个是镇压人民反抗，但还有一个很重要的作用，就是遏制贵族的贪欲，限制他们对人民的剥夺，并强迫贵族、地主、资本家这些有钱有权的阶层多出钱来支持战争。用独裁君主制代替封建制度，是英国从弱到强的关键。等到殖民战争和争霸战争打赢了，最艰难的时刻过去了，殖民统治体系建立起来了，有众多海外殖民地可供掠夺，资源分配条件变得宽松。利益集团内部，不需要进行你死我活的斗争了；统治精英们富得流油的同时，底层人民的税负也不高、福利还不错。这种情况下，专制君主就成了一个累赘。大家就觉得还是民主好，独裁君主对贵族精英们管束的太严了、收的钱太多了，让精英们很不舒服，可以搞个科学的程序来做决策，各大利益集团选择自己的代表大家开个会各抒己见就挺好的。贵族、地主、资本家就联合起来把专制君主推翻了。决策程序慢一点没关系，吵架厉害一点没关系，不会耽误大事，利益集团之间也不会当真打起来，代议制民主就取代了独裁君主制。<br><br>近代中国的革命和改良，基本主线是中国人民与满清、汉族官僚士绅、外国列强三股反动势力反复博弈的过程。太平天国试图以底层革命的方式一次性推翻三大反动势力，壮烈失败。此后，满洲和汉族官僚士绅联合起来搞“洋务运动”，想以此富国强兵、抵御外辱，以甲午惨败结束。然后，义和团运动试图采取“扶清灭洋”的路线，联合国内两股势力共同抵御列强，遭到了汉族官僚的拒绝和满清的背叛，又被三大反动势力联合镇压。《辛丑条约》以后，满清全面投靠列强，倚靠列强榨取汉族士绅和中国人民的利益，结果就是汉族官僚士绅们开始跟革命党合作，以谋求终结满清专制，最终诱发了辛亥革命。</p>
</blockquote>
<h2 id="历史周期律"><a href="#历史周期律" class="headerlink" title="历史周期律"></a>历史周期律</h2><blockquote>
<p>历史课本告诉我们：中国封建社会存在着互相对立、彼此消长的两种土地所有制: 一是封建地主土地所有制( 包含地主阶级的国有土地制) ， 一是农民小块土地所有制。前者占支配地位， 后者为其补充。这样中国封建土地所有制实质就是封建地主土地所有制， 基本特点是土地所有权高度集中在地主阶级手中。小农经济具有其抗风险能力差的特点，普通农户家庭一旦遇到水旱蝗灾、年景歉收或是婚丧嫁娶、疾病，就不得不以土地作为抵押，从地主乡绅那里获取高利贷。<br><br>然而就像马克思和无数学者所证明的那样，历来资本的边际收益要高于劳动的边际收益，因此这就注定了在许多情况下，农民辛苦劳作所取得的收益是无法偿还高利贷的利息的。这样就在利息的“驴打滚”中恶性循环，直至将被抵押的土地偿还给地主，成为佃农，更惨一点的，就是流民。万历年间一份奏折指出：“或因水旱饥荒，及粮差繁并，或被势要相侵，及钱债驱迫，不得已将起科腴田，减其价直，典卖……”。相关的文学作品可以参考《白毛女》和茅盾先生的《春种》《秋收》。<br><br>然而，问题就来了，地主兼并农民土地，是一个线性增长财富集中愈演愈烈的趋势，但是问题就来了，因为地主士绅兼并的这些土地是不向国家交税的：<br><br>这就是造成中国封建王朝兴衰周期律的根本原因之一。土地越来越多地集中在特权阶层手中，国家能得到的赋税也就越来越少；另一方面失地流民越来越多，镇压、安抚农民起义又需要大量的财政收入，这对于封建王朝来说是一个死局。土地越集中在这些特权阶层的手中，国家受到的利益损失就越大，这就是历史上的所谓“ 锄豪强， 抑兼并”的经济思想和政策产生的经济根源。但是从公元前七年汉哀帝绥和二年颁布的封建史上的第一次限田令以来， 诸如王莽的王田制、晋初的占田制、北魏的均田制等等， 无不在既得利益的缙绅、官僚、豪强的反对下，成为一纸空文，不能实施。<br><br>来源：微信公众号”大浪淘沙”</p>
</blockquote>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
        <category>哲学/历史</category>
      </categories>
      <tags>
        <tag>哲学/历史</tag>
      </tags>
  </entry>
  <entry>
    <title>线索化二叉树</title>
    <url>/posts/45955.html</url>
    <content><![CDATA[<blockquote>
<p>本文总结一下先序、中序和后序线索化二叉树。</p>
</blockquote>
<span id="more"></span>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p>对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。</p>
<h2 id="线索二叉树结构"><a href="#线索二叉树结构" class="headerlink" title="线索二叉树结构"></a>线索二叉树结构</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag; <span class="comment">// 左、右线索标志：0：孩子；1：前驱</span></span><br><span class="line">    <span class="built_in">ThreadNode</span>(<span class="keyword">int</span> x) : <span class="built_in">data</span>(x), <span class="built_in">lchild</span>(<span class="literal">nullptr</span>), <span class="built_in">rchild</span>(<span class="literal">nullptr</span>), <span class="built_in">ltag</span>(<span class="number">0</span>), <span class="built_in">rtag</span>(<span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ThreadNode* ThreadTree;</span><br></pre></td></tr></table></figure>

<h2 id="中序线索化二叉树"><a href="#中序线索化二叉树" class="headerlink" title="中序线索化二叉树"></a>中序线索化二叉树</h2><h3 id="中序线索化"><a href="#中序线索化" class="headerlink" title="中序线索化"></a>中序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;lchild, pre);  </span><br><span class="line">    <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;  </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">InThread</span>(p-&gt;rchild, pre);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树"><a href="#建立线索化二叉树" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点"><a href="#求第一个节点" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild; <span class="comment">// 最左下节点，不一定是叶节点</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点"><a href="#求后继节点" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// rtag=1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的中序线索二叉树的中序遍历"><a href="#不含头结点的中序线索二叉树的中序遍历" class="headerlink" title="不含头结点的中序线索二叉树的中序遍历"></a>不含头结点的中序线索二叉树的中序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序线索化二叉树上实现前序遍历的算法"><a href="#中序线索化二叉树上实现前序遍历的算法" class="headerlink" title="中序线索化二叉树上实现前序遍历的算法"></a>中序线索化二叉树上实现前序遍历的算法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadNode* node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;data);  <span class="comment">// 先访问根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;ltag == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 有左子树，即为后继</span></span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;rtag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 有柚子树，即为后继</span></span><br><span class="line">            node = node-&gt;rchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无左右子树</span></span><br><span class="line">            <span class="keyword">while</span>(node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;rtag==<span class="number">1</span>) <span class="comment">// 检测后继线索 直到找到有右子树的结点</span></span><br><span class="line">                node = node-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                node =node-&gt;rchild;  <span class="comment">//该结点的右子树为后继</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="前序线索化二叉树"><a href="#前序线索化二叉树" class="headerlink" title="前序线索化二叉树"></a>前序线索化二叉树</h2><h3 id="前序线索化"><a href="#前序线索化" class="headerlink" title="前序线索化"></a>前序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">PreThread</span>(p-&gt;lchild, pre);    </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">PreThread</span>(p-&gt;rchild, pre);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树-1"><a href="#建立线索化二叉树-1" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">nullptr</span>;  <span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点-1"><a href="#求第一个节点-1" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点-1"><a href="#求后继节点-1" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;lchild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;  <span class="comment">// rtag=1 直接返回后继线索</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的前序线索二叉树的前序遍历"><a href="#不含头结点的前序线索二叉树的前序遍历" class="headerlink" title="不含头结点的前序线索二叉树的前序遍历"></a>不含头结点的前序线索二叉树的前序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后序线索化二叉树"><a href="#后序线索化二叉树" class="headerlink" title="后序线索化二叉树"></a>后序线索化二叉树</h2><h3 id="后序线索化"><a href="#后序线索化" class="headerlink" title="后序线索化"></a>后序线索化</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree&amp; p, ThreadTree&amp; pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 线索化左子树</span></span><br><span class="line">    <span class="built_in">PostThread</span>(p-&gt;lchild, pre);    </span><br><span class="line">    <span class="comment">// 线索化右子树</span></span><br><span class="line">    <span class="built_in">PostThread</span>(p-&gt;rchild, pre);</span><br><span class="line">        <span class="comment">// 左子树为空，建立前驱索引</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 建立前驱索引的后继索引</span></span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; pre-&gt;rchild==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = p;   </span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记当前节点为刚访问过得节点</span></span><br><span class="line">    pre = p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="建立线索化二叉树-2"><a href="#建立线索化二叉树-2" class="headerlink" title="建立线索化二叉树"></a>建立线索化二叉树</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T, pre);</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild = <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 处理遍历的最后一个结点</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求第一个节点-2"><a href="#求第一个节点-2" class="headerlink" title="求第一个节点"></a>求第一个节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">FirstNode</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    TreeNode *p = T;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;lchild || p-&gt;rchild) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;lchild) &#123;</span><br><span class="line">                p = p-&gt;lchild;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            p = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求父节点"><a href="#求父节点" class="headerlink" title="求父节点"></a>求父节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Parent</span><span class="params">(TreeNode* node, ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span> || T==<span class="literal">nullptr</span> || node==T) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild==node || T-&gt;rchild==node) </span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    </span><br><span class="line">    TreeNode *left = <span class="built_in">Parent</span>(node, T-&gt;lchild);</span><br><span class="line">    TreeNode *right = <span class="built_in">Parent</span>(node, T-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> left==<span class="literal">nullptr</span> ? right : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求后继节点-2"><a href="#求后继节点-2" class="headerlink" title="求后继节点"></a>求后继节点</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode* <span class="title">NextNode</span><span class="params">(ThreadNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*返回后序线索二叉树后继结点，如果rtag=0，则返回当前节点父节点的FirstNode</span></span><br><span class="line"><span class="comment">        如果父节点无右子树，则返回父节点本身，即左孩子后继为父节点*/</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(<span class="built_in">Parent</span>(p));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不含头结点的后序线索二叉树的后序遍历"><a href="#不含头结点的后序线索二叉树的后序遍历" class="headerlink" title="不含头结点的后序线索二叉树的后序遍历"></a>不含头结点的后序线索二叉树的后序遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">nullptr</span>; p = <span class="built_in">NextNode</span>(p))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
        <category>二叉树</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口算法总结</title>
    <url>/posts/39893.html</url>
    <content><![CDATA[<blockquote>
<p>滑动窗口是一种很精妙、面试也常考的算法。本文总结一下滑动窗口的套路^.^。</p>
</blockquote>
<span id="more"></span>

<h2 id="算法模板框架"><a href="#算法模板框架" class="headerlink" title="算法模板框架"></a>算法模板框架</h2><blockquote>
<p>滑动窗口算法的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。这里总结一套滑动窗口算法的通用模板：<br><br>来源：labuladong的算法小抄</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SlideWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="comment">// c是将移入窗口的字符</span></span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        <span class="comment">// 右移窗口</span></span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*** debug 输出位置 ***/</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d]\n&quot;</span>, left, right);</span><br><span class="line">        <span class="comment">/*********************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断左侧窗口是否要收缩</span></span><br><span class="line">        <span class="keyword">while</span>(window needs shrink) &#123;</span><br><span class="line">            <span class="comment">// d是将移出窗口的字符</span></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 进行窗口数据的一系列更新</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="leetcode题目"><a href="#leetcode题目" class="headerlink" title="leetcode题目"></a>leetcode题目</h2><h3 id="74-最小覆盖子串"><a href="#74-最小覆盖子串" class="headerlink" title="74.最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">74.最小覆盖子串</a></h3><blockquote>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “”。<br>滑动窗口解法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">   unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>, maxlen = INT_MAX;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c]) </span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(valid &gt;= need.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(right-left &lt; maxlen) &#123;</span><br><span class="line">                maxlen = right - left;</span><br><span class="line">                start = left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxlen==INT_MAX ? <span class="string">&quot;&quot;</span> : s.<span class="built_in">substr</span>(start, maxlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3><blockquote>
<p>给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。<br><br>换句话说，s1 的排列之一是 s2 的 子串 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : s1) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s2[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right-left &gt;= s1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>()) </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span> d = s2[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d]) </span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><blockquote>
<p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br><br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : p) need[c]++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(need.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">            window[c]++;</span><br><span class="line">            <span class="keyword">if</span>(window[c] == need[c])</span><br><span class="line">                valid++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(right-left &gt;= p.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(valid == need.<span class="built_in">size</span>())</span><br><span class="line">                res.<span class="built_in">push_back</span>(left);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>(need.<span class="built_in">count</span>(d)) &#123;</span><br><span class="line">                <span class="keyword">if</span>(window[d] == need[d])</span><br><span class="line">                    valid--;</span><br><span class="line">                window[d]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><blockquote>
<p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串的长度.</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = s[right];</span><br><span class="line">        right++;</span><br><span class="line"></span><br><span class="line">        window[c]++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> d = s[left];</span><br><span class="line">            left ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(window.<span class="built_in">count</span>(d)) </span><br><span class="line">                window[d]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, right-left);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>滑动窗口算法的思路是这样：<br>1.我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。<br>2.我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。<br>3.此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。<br>4.重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。<br>这个思路其实也不难，第 2 步相当于在寻找一个<strong>可行解</strong>，然后第 3 步在优化这个<strong>可行解</strong>，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微软CSS三面凉经</title>
    <url>/posts/39426.html</url>
    <content><![CDATA[<blockquote>
<p>参加了微软CSS（技术支持）岗位的面试，面经奉上~。</p>
</blockquote>
<span id="more"></span>

<h2 id="一面（220307上午）"><a href="#一面（220307上午）" class="headerlink" title="一面（220307上午）"></a>一面（220307上午）</h2><h3 id="英文自我介绍"><a href="#英文自我介绍" class="headerlink" title="英文自我介绍"></a>英文自我介绍</h3><p>教育背景，专业技能，为什么来微软，为什么选CSS<br>本来准备了英语介绍，结果没背熟，，，硬着头皮说完了，看面试官表情当时感觉就无了</p>
<h3 id="专业问题"><a href="#专业问题" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul>
<li>OSI七层模型是什么，每层分别介绍一下</li>
<li>Http和Https区别</li>
</ul>
<h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul>
<li>静态成员、非静态成员区别，在内存哪个区</li>
<li>指针变量占多少空间</li>
<li>说说析构函数</li>
<li>C++动态内存分配方法</li>
<li>头文件作用</li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li>进程、线程区别</li>
<li>线程调度的时机</li>
</ul>
<h2 id="二面（220307下午）"><a href="#二面（220307下午）" class="headerlink" title="二面（220307下午）"></a>二面（220307下午）</h2><h3 id="中文自我介绍"><a href="#中文自我介绍" class="headerlink" title="中文自我介绍"></a>中文自我介绍</h3><p>对CSS了解吗，为什么选CSS</p>
<h3 id="专业问题-1"><a href="#专业问题-1" class="headerlink" title="专业问题"></a>专业问题</h3><h4 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h4><ul>
<li>Http和Https区别</li>
<li>Https如何work</li>
</ul>
<h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul>
<li>介绍下用户空间、内核空间，用户态如何切内核态</li>
<li>static关键字</li>
</ul>
<h4 id="Role-Play"><a href="#Role-Play" class="headerlink" title="Role Play"></a>Role Play</h4><p><strong>英文场景题</strong>面试官是客户（老外），将网站部署在Microsoft云平台上，突然宕机了。全程英文来交流~ 然后就是大型翻车现场。。。</p>
<h2 id="三面（220309上午）"><a href="#三面（220309上午）" class="headerlink" title="三面（220309上午）"></a>三面（220309上午）</h2><ul>
<li>自我介绍</li>
<li>对CSS的理解，如何了解客户需求，帮助客户解决问题</li>
<li>自我职业规划</li>
<li>对云计算的理解（面试官是Azure部门的）</li>
<li>英文场景题，客户web server 宕机，要求今天解决，你如何回复（英文）</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次微软面试经历，值得吸取的教训还是很多的</p>
<ul>
<li>首先因为第一次面试，可能略有紧张。自我介绍都翻车了。。。</li>
<li>八股文问的不深，但是细节还是没掌握。比如表示层会话层之前只是走马观花看了一下，结果现场想不起来了，和面试官大眼瞪小眼</li>
<li>认识到自己还有很多不足（英文口语、表达能力、应变能力等），以后要谨言慎行、谦虚谨慎、戒骄戒躁了~</li>
</ul>
<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>面试</category>
        <category>Microsoft</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode链表</title>
    <url>/posts/6854.html</url>
    <content><![CDATA[<blockquote>
<p>链表可拿来考验程序员基本功，代码短小精悍，颇有四两拨千斤之感~。</p>
</blockquote>
<span id="more"></span>

<h2 id="链表结构定义"><a href="#链表结构定义" class="headerlink" title="链表结构定义"></a>链表结构定义</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h2><blockquote>
<p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<br>本题有两种解决思路，一种递归一种迭代，思路都很精巧，下面来一一介绍：</p>
</blockquote>
<h3 id="1、递归解法"><a href="#1、递归解法" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 链表为空；head指向尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代解法"><a href="#2、迭代解法" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><h4 id="迭代解法一（带dummy结点）"><a href="#迭代解法一（带dummy结点）" class="headerlink" title="迭代解法一（带dummy结点）"></a>迭代解法一（带dummy结点）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode *_next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = cur;</span><br><span class="line">        cur = _next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迭代解法二（不带dummy结点）"><a href="#迭代解法二（不带dummy结点）" class="headerlink" title="迭代解法二（不带dummy结点）"></a>迭代解法二（不带dummy结点）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        LisNode *next = head-&gt;next;</span><br><span class="line">        head-&gt;next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h2><blockquote>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置  left 到位置 right 的链表节点，返回 反转后的链表。</p>
</blockquote>
<h3 id="1、递归解法-1"><a href="#1、递归解法-1" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head-&gt;next = <span class="built_in">reverseBetween</span>(head-&gt;next, left<span class="number">-1</span>, right<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *successor = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        successor = head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">reverseN</span>(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = successor;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、迭代解法-1"><a href="#2、迭代解法-1" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">    ListNode *pre = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; left<span class="number">-1</span>; i++) </span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *cur = pre-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt; right; i++) &#123;</span><br><span class="line">        ListNode *t = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = pre-&gt;next;</span><br><span class="line">        pre-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br>k 是一个正整数，它的值小于或等于链表的长度。<br>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *a = head, *b = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">nullptr</span>) <span class="keyword">return</span> a;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *newHead = <span class="built_in">revList</span>(a, b);</span><br><span class="line">    a-&gt;next = <span class="built_in">reverseKGroup</span>(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">revList</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    ListNode *pre = <span class="literal">nullptr</span>, *cur = a;</span><br><span class="line">    <span class="keyword">while</span>(cur != b) &#123;</span><br><span class="line">        ListNode *nxt = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = nxt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h2><blockquote>
<p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。<br>如果是，返回 true ；否则，返回 false 。</p>
</blockquote>
<h3 id="1、递归解法-2"><a href="#1、递归解法-2" class="headerlink" title="1、递归解法"></a>1、递归解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ListNode *left = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    left = head;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">traverse</span>(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">traverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">traverse</span>(right-&gt;next);</span><br><span class="line">    res = res &amp;&amp; (left-&gt;val == right-&gt;val);</span><br><span class="line">    left = left-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、迭代解法-2"><a href="#2、迭代解法-2" class="headerlink" title="2、迭代解法"></a>2、迭代解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在2；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *last = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next) &#123;</span><br><span class="line">        ListNode *t = last-&gt;next;</span><br><span class="line">        last-&gt;next = t-&gt;next;</span><br><span class="line">        t-&gt;next = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode *pre = head, *post = slow-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(post != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;val != post-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        post = post-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><blockquote>
<p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, <span class="literal">nullptr</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(list1 &amp;&amp; list2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">            cur-&gt;next = list1;</span><br><span class="line">            list1 = list1-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur-&gt;next = list2;</span><br><span class="line">            list2 = list2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(list1) cur-&gt;next = list1;</span><br><span class="line">    <span class="keyword">if</span>(list2) cur-&gt;next = list2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h2><blockquote>
<p>给你一个链表的头节点 head ，判断链表中是否有环。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。<br>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == slow) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><blockquote>
<p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<br>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>不允许修改链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h2><blockquote>
<p>给定一个头结点为 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    <span class="comment">// 这里要注意，只有这样写，【1,2,3,4】slow会在3；【1,2,3,4,5】slow会在3</span></span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><blockquote>
<p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。 如果两个链表不存在相交节点，返回 null 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    ListNode *pa = headA, *pb = headB;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> la = <span class="built_in">length</span>(headA);</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="built_in">length</span>(headB);</span><br><span class="line">    <span class="keyword">if</span>(la &gt; lb) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = la - lb;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pa = pa-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = lb - la;</span><br><span class="line">        <span class="keyword">while</span>(diff--) pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pa &amp;&amp; pb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pa == pb) <span class="keyword">return</span> pa;</span><br><span class="line">        pa = pa-&gt;next;</span><br><span class="line">        pb = pb-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode* list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    ListNode* cur = list;</span><br><span class="line">    <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><blockquote>
<p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    </span><br><span class="line">    ListNode *slow = dummy;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *t = slow-&gt;next;</span><br><span class="line">    slow-&gt;next= slow-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-合并K个升序链表"><a href="#23-合并K个升序链表" class="headerlink" title="23. 合并K个升序链表"></a><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><blockquote>
<p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dummy;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(node);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        cur-&gt;next = t;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;next) pq.<span class="built_in">push</span>(cur-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode-cn.com/classic/problems/sort-list/description/">148. 排序链表</a></h2><blockquote>
<p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *slow = head, *fast = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* half1 = <span class="built_in">sortList</span>(head);</span><br><span class="line">        ListNode* half2 = <span class="built_in">sortList</span>(slow);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergeList</span>(half1, half2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeList</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span>(l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a href="https://leetcode-cn.com/classic/problems/odd-even-linked-list/description/">328. 奇偶链表</a></h2><blockquote>
<p>定单链表的头节点 head ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。第一个节点的索引被认为是 奇数 ， 第二个节点的索引为 偶数 ，以此类推。<br>请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。<br>你必须在 O(1) 的额外空间复杂度和 O(n) 的时间复杂度下解决这个问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    ListNode *evenHead = head-&gt;next;</span><br><span class="line">    ListNode *odd = head, *even = evenHead;</span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next) &#123;</span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">        even-&gt;next = odd-&gt;next;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    odd-&gt;next = evenHead;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU和LFU缓存实现</title>
    <url>/posts/13455.html</url>
    <content><![CDATA[<blockquote>
<p>本文就来介绍一下LRU和LFU的具体实现，废话不多说，看代码~。</p>
</blockquote>
<span id="more"></span>

<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a></h2><blockquote>
<p>请你设计并实现一个满足  LRU (最近最少使用) 缓存约束的数据结构。<br>实现 LRUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 刚访问过的结点移动到链表头</span></span><br><span class="line">        lst.<span class="built_in">splice</span>(lst.<span class="built_in">begin</span>(), l, it-&gt;<span class="built_in">second</span>());</span><br><span class="line">        <span class="keyword">return</span> m[key]-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="comment">// key已经存在，抹去</span></span><br><span class="line">        <span class="keyword">if</span>(it != m.<span class="built_in">end</span>()) lst.<span class="built_in">erase</span>(it);</span><br><span class="line">        <span class="comment">// 插入链表头</span></span><br><span class="line">        lst.<span class="built_in">push_front</span>(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        <span class="comment">// 建立key到list迭代器的映射</span></span><br><span class="line">        m[key] = lst.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="comment">// 元素个数超过缓存容量大小</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt; cap) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = lst.<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">            <span class="comment">// 删除链表末尾（最近最少使用）元素</span></span><br><span class="line">            lst.<span class="built_in">pop_back</span>();</span><br><span class="line">            m.<span class="built_in">erase</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 缓存容量</span></span><br><span class="line">    <span class="keyword">int</span> cap;  </span><br><span class="line">    <span class="comment">// 链表，元素为（key，value）对</span></span><br><span class="line">    list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; lst;</span><br><span class="line">    <span class="comment">// 哈希表，key--&gt;（key，value）迭代器</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt;::iterator&gt; m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="460-LFU-缓存"><a href="#460-LFU-缓存" class="headerlink" title="460. LFU 缓存"></a><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a></h2><blockquote>
<p>请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。<br>实现 LFUCache 类：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LFUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LFUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        cap = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">count</span>(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 将结点从freq list里摘除</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">erase</span>(iter[key]);</span><br><span class="line">        <span class="comment">// freq自增1</span></span><br><span class="line">        ++m[key].second;</span><br><span class="line">        <span class="comment">// 加入freq+1 list 表尾</span></span><br><span class="line">        freq[m[key].second].<span class="built_in">push_back</span>(key);</span><br><span class="line">        <span class="comment">// 更新迭代器位置</span></span><br><span class="line">        iter[key] = --freq[m[key].second].<span class="built_in">end</span>();</span><br><span class="line">        <span class="comment">// 如果minFreq list 为空，则minFreq++</span></span><br><span class="line">        <span class="keyword">if</span>(freq[minFreq].<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            ++minFreq;</span><br><span class="line">        <span class="comment">// 返回key对应的value</span></span><br><span class="line">        <span class="keyword">return</span> m[key].first;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 该key之前已经存在，更新value即可</span></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">get</span>(key) != <span class="number">-1</span>) &#123;</span><br><span class="line">            m[key] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">size</span>() &gt;= cap) &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            iter.<span class="built_in">erase</span>(freq[minFreq].<span class="built_in">front</span>());</span><br><span class="line">            freq[minFreq].<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m[key] = &#123;value, <span class="number">1</span>&#125;;</span><br><span class="line">        freq[<span class="number">1</span>].<span class="built_in">push_back</span>(key);</span><br><span class="line">        iter[key] = --freq[<span class="number">1</span>].<span class="built_in">end</span>();</span><br><span class="line">        minFreq = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 容量，最小频率</span></span><br><span class="line">    <span class="keyword">int</span> cap, minFreq;</span><br><span class="line">    <span class="comment">// key--&gt;(value, freq)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; m;</span><br><span class="line">    <span class="comment">// freq--&gt;list：频率为freq对应的key存在一个list里</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt; &gt; freq;</span><br><span class="line">    <span class="comment">// key--&gt;list&lt;int&gt;::iterator，保存key在对应freq list里的迭代器，为了实现查找O(1)</span></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, list&lt;<span class="keyword">int</span>&gt;::iterator&gt; iter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache* obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>位我上者，灿烂星空；道德律令，在我心中。</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
        <category>LRU</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/posts/46268.html</url>
    <content><![CDATA[<blockquote>
<p>本文总结一下并查集在实际问题中的应用，体会一下并查集的精巧的构思^.^。</p>
</blockquote>
<span id="more"></span>

<blockquote>
<p><a href="https://labuladong.gitee.io/algo/2/20/40/">并查集的教程——来自labuladong</a></p>
</blockquote>
<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><blockquote>
<p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mp[num] = <span class="number">1</span>; cnt[num] = <span class="number">1</span>; fa[num] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[num+<span class="number">1</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, <span class="built_in">merge</span>(num+<span class="number">1</span>, num));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x != fa[x]) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt[rootX];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> _cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(cnt[rootX] &gt; cnt[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            cnt[rootX] += cnt[rootY];</span><br><span class="line">            _cnt = cnt[rootX];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            cnt[rootY] += cnt[rootX];</span><br><span class="line">            _cnt = cnt[rootY]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> _cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp, cnt, fa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="130-被围绕的区域"><a href="#130-被围绕的区域" class="headerlink" title="130. 被围绕的区域"></a><a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h2><blockquote>
<p>给你一个 m x n 的矩阵 board ，由若干字符 ‘X’ 和 ‘O’ ，找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; dir = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = board.<span class="built_in">size</span>(), m = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span> || m==<span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dummy = m*n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n*m; i++) &#123;</span><br><span class="line">            fa[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) </span><br><span class="line">                <span class="built_in">merge</span>(i*m, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[i][m<span class="number">-1</span>] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i*m+m<span class="number">-1</span>, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>(i, dummy);</span><br><span class="line">            <span class="keyword">if</span>(board[n<span class="number">-1</span>][i] == <span class="string">&#x27;O&#x27;</span>)</span><br><span class="line">                <span class="built_in">merge</span>((n<span class="number">-1</span>)*m+i, dummy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                        <span class="keyword">int</span> x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">int</span> y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(board[x][y] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                            <span class="built_in">merge</span>(x*m+y, i*m+j);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m<span class="number">-1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">connected</span>(i*m+j, dummy)) </span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootX==rootY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><blockquote>
<p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(fa[x] != x) &#123;</span><br><span class="line">            fa[x] = fa[fa[x]];</span><br><span class="line">            x = fa[x];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sz[rootX] &gt; sz[rootY]) &#123;</span><br><span class="line">            fa[rootY] = rootX;</span><br><span class="line">            sz[rootX] += sz[rootY];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fa[rootX] = rootY;</span><br><span class="line">            sz[rootY] += sz[rootX];</span><br><span class="line">        &#125;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx  =i*m + j;</span><br><span class="line">                fa[idx] = idx;</span><br><span class="line">                sz[idx] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> idx = i*m + j;</span><br><span class="line">                    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n &amp;&amp; grid[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i+<span class="number">1</span>)*m+j);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(j+<span class="number">1</span>&lt;m &amp;&amp; grid[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                        <span class="built_in">merge</span>(idx, (i*m)+j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; fa, sz;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS和BFS套路总结</title>
    <url>/posts/51190.html</url>
    <content><![CDATA[<blockquote>
<p>本文总结一下DFS和BFS算法，体会计算机搜索的奥（笨）妙（拙）~。</p>
</blockquote>
<span id="more"></span>

<h2 id="431-找无向图的连通块"><a href="#431-找无向图的连通块" class="headerlink" title="431. 找无向图的连通块"></a><a href="">431. 找无向图的连通块</a></h2><blockquote>
<p>找出无向图中所有的连通块。<br>图中的每个节点包含一个label属性和一个邻接点的列表。（一个无向图的连通块是一个子图，其中任意两个顶点通过路径相连，且不与整个图中的其它顶点相连。）<br>你需要返回 label 集合的列表.</p>
</blockquote>
<h3 id="1、DFS解法"><a href="#1、DFS解法" class="headerlink" title="1、DFS解法"></a>1、DFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;neighbors.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis.<span class="built_in">count</span>(node-&gt;neighbors[i])) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;neighbors[i], cur);</span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、BFS解法"><a href="#2、BFS解法" class="headerlink" title="2、BFS解法"></a>2、BFS解法</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;UndirectedGraphNode*&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">connectedSet</span>(vector&lt;UndirectedGraphNode*&gt; nodes) &#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis.<span class="built_in">count</span>(nodes[i])) &#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="comment">// dfs(nodes[i], cur);</span></span><br><span class="line">            <span class="built_in">bfs</span>(nodes[i], cur);</span><br><span class="line">            <span class="built_in">sort</span>(cur.<span class="built_in">begin</span>(), cur.<span class="built_in">end</span>());</span><br><span class="line">            res.<span class="built_in">push_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(UndirectedGraphNode* node, vector&lt;<span class="keyword">int</span>&gt;&amp; cur)</span> </span>&#123;</span><br><span class="line">    queue&lt;UndirectedGraphNode*&gt; q;</span><br><span class="line">    vis.<span class="built_in">insert</span>(node);</span><br><span class="line">    q.<span class="built_in">push</span>(node);</span><br><span class="line">    cur.<span class="built_in">push_back</span>(node-&gt;label);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        UndirectedGraphNode* tnode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> neighbor : tnode-&gt;neighbors) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis.<span class="built_in">count</span>(neighbor)) <span class="keyword">continue</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">            cur.<span class="built_in">push_back</span>(neighbor-&gt;label);</span><br><span class="line">            vis.<span class="built_in">insert</span>(neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
        <category>DFS-BFS</category>
      </categories>
      <tags>
        <tag>DFS—BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀树（Trie）</title>
    <url>/posts/8911.html</url>
    <content><![CDATA[<blockquote>
<p>本文总结一下一种常见的高级数据结构——前缀树（Trie）</p>
</blockquote>
<span id="more"></span>

<h2 id="前缀树（Trie）介绍"><a href="#前缀树（Trie）介绍" class="headerlink" title="前缀树（Trie）介绍"></a>前缀树（Trie）介绍</h2><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><blockquote>
<p>请你实现 Trie 类：<br>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串 word 。<br>boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TrieNode* child[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">bool</span> isWord;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) &#123;</span><br><span class="line">            a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            cur = cur-&gt;child[id]; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cur-&gt;isWord;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = prefix[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode* root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie* obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj-&gt;insert(word);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(word);</span></span><br><span class="line"><span class="comment"> * bool param_3 = obj-&gt;startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="648-单词替换"><a href="#648-单词替换" class="headerlink" title="648. 单词替换"></a><a href="https://leetcode-cn.com/problems/replace-words/">648. 单词替换</a></h2><blockquote>
<p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。<br>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。<br>你需要输出替换之后的句子。 </p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        TrieNode *root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(string&amp; word : dictionary) </span><br><span class="line">            <span class="built_in">insert</span>(root, word);</span><br><span class="line">        </span><br><span class="line">        <span class="function">istringstream <span class="title">in</span><span class="params">(sentence)</span></span>;</span><br><span class="line">        string t = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(in &gt;&gt; t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.<span class="built_in">empty</span>()) res += <span class="string">&quot; &quot;</span>;</span><br><span class="line">            res += <span class="built_in">findPrefix</span>(root, t);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            </span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">findPrefix</span><span class="params">(TrieNode* node, string&amp; word)</span> </span>&#123;</span><br><span class="line">        string cur = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            cur.<span class="built_in">push_back</span>(c);</span><br><span class="line">            node = node-&gt;child[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;isWord) <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TrieNode *root;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="676-实现一个魔法字典"><a href="#676-实现一个魔法字典" class="headerlink" title="676. 实现一个魔法字典"></a><a href="https://leetcode-cn.com/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></h2><blockquote>
<p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TrieNode *child[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">bool</span> isWord;</span><br><span class="line">        <span class="built_in">TrieNode</span>() : <span class="built_in">isWord</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; a : child) </span><br><span class="line">                a = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    TrieNode *root;</span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dictionary.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(root, dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, searchWord, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TrieNode* root, string&amp; word, <span class="keyword">int</span> i, <span class="keyword">int</span> edit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root-&gt;isWord==<span class="literal">true</span> &amp;&amp; i==word.<span class="built_in">size</span>() &amp;&amp; edit==<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i&lt;word.<span class="built_in">size</span>() &amp;&amp; edit&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;<span class="number">26</span> &amp;&amp; !found; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> newEdit = (word[i]-<span class="string">&#x27;a&#x27;</span> == j) ? edit : edit+<span class="number">1</span>;</span><br><span class="line">                found = <span class="built_in">dfs</span>(root-&gt;child[j], word, i+<span class="number">1</span>, newEdit);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(TrieNode* root, string&amp; word)</span> </span>&#123;</span><br><span class="line">        TrieNode *cur = root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> id = word[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;child[id] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                cur-&gt;child[id] = <span class="keyword">new</span> <span class="built_in">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;child[id];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>前缀树</category>
      </categories>
      <tags>
        <tag>Trie</tag>
      </tags>
  </entry>
</search>
